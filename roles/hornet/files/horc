#!/usr/bin/env bash
set -o pipefail

# This is just a proof-of-concept. Use with care.
# Only use if you installed your node using hornet-playbook

if [[ $EUID -ne 0 ]]; then
   echo "This script must be run as root"
   echo "Please change to root: 'sudo su -' and re-run"
   exit 1
fi

clear

[ -f "$HOME/.horc" ] && . "$HOME/.horc"
[ -f "/opt/hornet-playbook/inventory-multi" ] && INVENTORY_FILE=inventory-multi || INVENTORY_FILE=inventory

: "${EDITOR:=nano}"
VERSION_TEMP=0.3.1
__VERSION__=${VERSION_TEMP}

: "${HORNET_BRANCH:=master}"
: "${HORC_BRANCH:=master}"
CUR_DIR="$(pwd)"

PID_FILE="/var/run/horc.pid"
WIDTH=78

# Source if exists
[ -f ~/.horc ] && . ~/.horc

export NEWT_COLORS='
window=,
'

# Check if another process of horc is already running.
if [ -e "$PID_FILE" ]
then
    PID_FROM_FILE=$(cat "$PID_FILE")
    if ps -fq $PID_FROM_FILE | grep -q "$(basename $0)$"
    then
        echo "ERROR: another instance of $(basename $0) is already running with pid ${PID_FROM_FILE}."
        exit 1
    fi
fi

# Cleanup function
function cleanup() {
    rm -f "$PID_FILE"
    cd "$CUR_DIR"
    trap - EXIT
    clear
}

# Write pid to pidfile
echo -n $$ >"$PID_FILE"

# Set exit trap
trap cleanup INT TERM EXIT

function pause(){
   read -p "$*"
   clear
}

# Get OS and Dist
function set_dist() {
    if [ -f /etc/os-release ]; then
        # freedesktop.org and systemd
        . /etc/os-release
        export OS=$NAME
        export VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
        # linuxbase.org
        export OS=$(lsb_release -si)
        export VER=$(lsb_release -sr)
    elif [ -f /etc/lsb-release ]; then
        # For some versions of Debian/Ubuntu without lsb_release command
        . /etc/lsb-release
        export OS=$DISTRIB_ID
        export VER=$DISTRIB_RELEASE
    elif [ -f /etc/debian_version ]; then
        # Older Debian/Ubuntu/etc.
        export OS=Debian
        export VER=$(cat /etc/debian_version)
    elif [ -f /etc/SuSe-release ]; then
        # Older SuSE/etc.
        echo "Unsupported OS."
        exit 1
    elif [ -f /etc/redhat-release ]; then
        # Older Red Hat, CentOS, etc.
        echo "Old OS version. Minimum required is 7."
        exit 1
    else
        # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
        export OS=$(uname -s)
        export VER=$(uname -r)
    fi

    # Set path to hornet's configuration file
    if [[ "$OS" =~ ^(CentOS|Red) ]]; then
        export SYSCONFIG_FILE=/etc/sysconfig/hornet
    elif [[ "$OS" =~ ^(Ubuntu|Debian|Raspbian) ]]; then
        export SYSCONFIG_FILE=/etc/default/hornet
    fi
}

function compare_versions() {
    local FIRST_VERSION=$(echo "$1" | tr -d 'v')
    local EVAL_STR=$2
    local SECOND_VERSION=$(echo "$3" | tr -d 'v')

    local GET_BOOL=$(python -c "from distutils.version import StrictVersion; print(StrictVersion('$FIRST_VERSION') $EVAL_STR StrictVersion('$SECOND_VERSION'))")
    if [[ "$GET_BOOL" == "True" ]]
    then
        return 0
    elif [[ "$GET_BOOL" == "False" ]]
    then
        return 1
    fi
}

### Playbook ###
function verify_playbook() {
    local OUTPUT
    local HEIGHT
    local RC
    if [ ! -d /opt/hornet-playbook ]; then
        cd /opt && git clone -b "$HORC_BRANCH" https://github.com/nuriel77/hornet-playbook.git
    fi
    cd /opt/hornet-playbook

    OUTPUT=$(git pull 2>&1)
    RC=$?
    HEIGHT=$(expr $(echo "$OUTPUT"|wc -l) + 10)
    if [[ $RC -ne 0 ]]; then
        whiptail --title "Git Errors" \
                 --msgbox "Errors when trying to update the playbook repository: $OUTPUT" \
                 $HEIGHT $WIDTH
        return 1
    fi
}

### Haproxy ###
function haproxy_listen_all() {
    # Expect to find 0.0.0.0 on same line or max 2 after var declaration.
    # If not found, add bind to all interfaces to override file.
    if ! grep ^lb_bind_addresses /opt/hornet-playbook/group_vars/all/z-installer-override.yml -A2 | grep -q '0.0.0.0'; then
        echo "lb_bind_addresses: ['0.0.0.0']" >> /opt/hornet-playbook/group_vars/all/z-installer-override.yml
    fi
}

function enable_https() {
    local POW
    local SSL_EMAIL
    local SSL_DOMAIN
    local ENABLE_NGINX_CERT

    if ! (whiptail --title "Enable HTTPS" \
                 --yesno "This option will enable HTTPS on Hornet's API port via HAProxy (port 14267 by default).\nAny previous configuration to HAProxy configuration will be overwritten.\nDo you want to proceed?" \
                 --defaultno \
                 12 $WIDTH) then
        return 1
    fi

    if (whiptail --title "Enable PoW" \
                 --yesno "Do you want to enable PoW (attachToTangle) on your node?" \
                 --defaultno \
                 12 $WIDTH) then
            POW=enabled
    else
            POW=disabled
    fi

    verify_playbook
    if [[ $? -ne 0 ]]; then
         whiptail --title "Error!" \
                  --msgbox "ERROR: Cannot enable HTTPS." \
                  8 $WIDTH
         return 1
    fi

    # Enable or disable PoW on this node via variable override file
    if [[ "$POW" == "enabled" ]]; then
        echo "haproxy_deny_regex: '(get|remove|add)Neighbors'" > /opt/hornet-playbook/group_vars/all/z-haproxy-regex-override.yml
    else
        echo "haproxy_deny_regex: '(get|remove|add)Neighbors|attachToTangle|interruptAttachingToTangle'" > /opt/hornet-playbook/group_vars/all/z-haproxy-regex-override.yml
    fi

    # Make sure we configure haproxy to listen on all interfaces, thereby enabling it.
    haproxy_listen_all

    # Enable haproxy https via variable override file
    echo "haproxy_https: True" > /opt/hornet-playbook/group_vars/all/z-haproxy-enable-https.yml

    cd /opt/hornet-playbook \
      && git pull \
      && ansible-playbook -i "$INVENTORY_FILE" \
         site.yml -v \
         --tags=py_docker,hornet_ssl,consul_role,loadbalancer_role,certbot \
         --skip-tags=consul_register_node \
         -e overwrite=yes

    if [[ $? -ne 0 ]]; then
        pause "Enabling HTTPS failed!!! Check output above for errors."
        clear
        return 1
    else
        clear
        if ! (whiptail --title "Request SSL Certificate" \
                 --yesno "HTTPS/SSL was enabled successfully. If you haven't done so yet, you can proceed in the next step to request a valid certificate for your domain. You must have a fully qualified domain name pointing to the IP address of your server.\n\nDo you want to proceed?" \
                 --defaultno \
                 18 $WIDTH) then
            return
        fi
    fi

    SSL_EMAIL=$(whiptail --inputbox "Enter your email address to register your SSL vertificate with:" 8 $WIDTH --title "Enter Email" 3>&1 1>&2 2>&3)
    if [[ $? -ne 0 ]]; then
        return
    fi

    SSL_DOMAIN=$(whiptail --inputbox "Enter the domain name to register the SSL certificate with:" 8 $WIDTH --title "Enter FQDN" 3>&1 1>&2 2>&3)
    if [[ $? -ne 0 ]]; then
        return
    fi

    if (whiptail --title "Configure Nginx" \
        --yesno "Do you also want to configure this certificate for nginx (Dashboard etc.) ?" \
        --defaultno \
        12 $WIDTH) then
        ENABLE_NGINX_CERT=yes
    else
        ENABLE_NGINX_CERT=false
    fi

    if ! (whiptail --title "Verify Details" \
          --yesno "You entered email '${SSL_EMAIL}' with domain '${SSL_DOMAIN}' and configure nginx with the certificate: '${ENABLE_NGINX_CERT}'\n\nIs this correct?" \
          --defaultno \
          12 $WIDTH) then
        return
    fi

    # Run the script to request a certificate
    /usr/local/bin/certbot-haproxy.sh "${SSL_EMAIL}" "${SSL_DOMAIN}"
    if [[ $? -ne 0 ]]; then
        pause "SSL Certificate request failed. See output above for more details."
        clear
        return 1
    fi

    # Subsequent requests to create new certificates (for example, original
    # directory was wiped) certbot will start appending an index for path name
    # We need to make sure we find a directory.
    FULL_PATH=$(find /etc/letsencrypt/live -type d -name "${SSL_DOMAIN}*" -print -quit)

    # Will ensure subsequent playbook runs will use haproxy.pem
    if [ -f "${FULL_PATH}/haproxy.pem" ]; then
        echo "ssl_certkey_file: ${FULL_PATH}/haproxy.pem" > /opt/hornet-playbook/group_vars/all/z-ssl-override.yml
    fi

    # Will configure nginx to use the let's encrypt certificates
    if [[ "$ENABLE_NGINX_CERT" == "yes" ]] && [ -f "${FULL_PATH}/cert.pem" ]; then
        if ! grep -q "^ssl_cert_file: ${FULL_PATH}/fullchain.pem" /opt/hornet-playbook/group_vars/all/z-ssl-override.yml; then
            cat <<EOF >> /opt/hornet-playbook/group_vars/all/z-ssl-override.yml
ssl_cert_file: ${FULL_PATH}/cert.pem
ssl_key_file: ${FULL_PATH}/privkey.pem
ssl_bundle_cert: ${FULL_PATH}/fullchain.pem
create_selfsigned_cert: False
letsencrypt: True
EOF
        fi
        # We don't enable nginx with this common certificate in multi node setup!
        cd /opt/hornet-playbook && ansible-playbook -i inventory -v site.yml --tags=configure_nginx_ssl
    fi

    pause "Done. Check above output to see the status of the request."
    clear
}

function enable_haproxy() {
    local DEFAULT_MSG="Are you sure you want to enable wallet access only via HAProxy?\nThis will disable port 14265 externally and make 14267 accessible.\nIn addition, all the REMOTE_LIMIT_API commands will be under control of HAProxy and no longer via Hornet's configuration files."
    [ -n "$1" ] && { DEFAULT_MSG=$1; }
    if (whiptail --title "HAProxy" \
                 --yesno "$DEFAULT_MSG" \
                 --defaultno \
                 8 $WIDTH) then
        verify_playbook
        if [[ $? -ne 0 ]]; then
             whiptail --title "Error!" \
                      --msgbox "ERROR: haproxy task failed." \
                      8 $WIDTH
             return 1
        fi

        # Make sure we configure haproxy to listen on all interfaces, thereby enabling it.
        haproxy_listen_all

        cd /opt/hornet-playbook && ansible-playbook -i inventory -v site.yml --tags=hornet_ssl,loadbalancer_role -e overwrite=yes
        [[ $? -ne 0 ]] && MSG="Enabling HAProxy failed!!! Check output above for errors." || MSG="Installation finished successfully!"
        pause "$MSG Press ENTER to return to menu."
    fi
}

### Hornet ###
function get_latest_hornet_commit {
    # Experimental/dev
    curl -H 'Cache-Control: no-cache' -s -m 5 -f "https://api.github.com/repos/gohornet/hornet/commits/$HORNET_BRANCH" | jq -r .sha | head -c 7
}

function get_latest_hornet_release {
    curl -H 'Cache-Control: no-cache' -s -m 5 -f https://api.github.com/repos/gohornet/hornet/releases/latest  | jq -r .tag_name
}

function check_new_hornet {
    local HORNET_LATEST
    local HORNET_VERSION

    HORNET_LATEST=$(get_latest_hornet_release)
    HORNET_VERSION=$(grep ^TAG "$SYSCONFIG_FILE" | cut -d= -f2)

    if compare_versions $HORNET_VERSION '<' $HORNET_LATEST; then
        return 0
    else
        return 1
    fi
}

function upgrade_hornet() {
    echo "Checking for updates..."
    local HORNET_LATEST
    local HORNET_VERSION

    HORNET_LATEST=$(get_latest_hornet_release)
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Failed to get Hornet's latest version\n${HORNET_LATEST}" \
                 8 $WIDTH
        return 1
    fi
    clear

    HORNET_VERSION=$(grep ^TAG "$SYSCONFIG_FILE" | cut -d= -f2)
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Failed to get current Hornet's version!" \
                 8 $WIDTH
        return 1
    fi

    # Only use compare_versions if real versions (e.g. semver)
    if compare_versions $HORNET_VERSION '>=' $HORNET_LATEST; then
        if ! (whiptail --title "No Updates" \
                 --yesno "You already have the latest version: ${HORNET_VERSION}.\nDo you want to proceed anyway?" \
                 --defaultno \
                 10 $WIDTH) then
            return
        else
            local NO_CONFIRM=1
        fi
    fi

    if [ -z "$NO_CONFIRM" ]; then
        if ! (whiptail --title "Upgrade Hornet" \
                     --yesno "Are you sure you want to upgrade Hornet from ${HORNET_VERSION} to ${HORNET_LATEST}?\nWARNING: only do this if you know what your are doing!" \
                     --defaultno \
                     8 $WIDTH) then
            return
        fi
    fi

    verify_playbook
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Cannot upgrade Hornet." \
                 8 $WIDTH
        return 1
    fi

    echo "Upgrading Docker image.... (Hornet will automatically restart if image gets updated)"
    cd /opt/hornet-playbook && ansible-playbook -i inventory \
                                -v site.yml \
                                --tags=build_hornet_image

    if [[ $? -ne 0 ]]; then
         whiptail --title "Error!" \
                  --msgbox "ERROR: Failed upgrading Hornet." \
                  8 $WIDTH
         rm -f "$TFILE"
         return 1
    fi

    if ! docker ps -a | sed '1d' | awk {'print $2'} | grep -q "$HORNET_LATEST"
    then
        echo "Force update tag and restart hornet ..."
        sed -i "s/^TAG=.*$/TAG=$HORNET_LATEST/" "$SYSCONFIG_FILE"
        /bin/systemctl restart hornet
    fi

    pause "Update finished successfully. Nevertheless, it is recommended to check the status of Hornet. Press ENTER to return to menu."
    clear
}

### Get DB ###
function get_db() {

    # Snapshot file name
    local SNAPSHOT_FILENAME="latest-export.gz.bin"

    # Playbook's default source
    DEFAULT_SOURCE=$(grep ^hornet_db_source /opt/hornet-playbook/group_vars/all/hornet.yml | awk {'print $2'} | tr -d '"')

    # Create array of available DB resources
    SOURCES_ARRAY=("$DEFAULT_SOURCE" "Custom")

    # Create an indexed array for building the menu
    SOURCES_ARRAY_INDEXED=($(printf "%s\n" "${SOURCES_ARRAY[@]}"| awk -F, '!/^ / && NF { print NR")"; print $1}'))

    # Output the menu
    SOURCE_INDEX=$(whiptail --title "Select DB Source" --menu "This action will download and boostrap a synced database.\nChoose a source where to download the database from:" 16 $WIDTH 4 "${SOURCES_ARRAY_INDEXED[@]}" 3>&1 1>&2 2>&3)
    if [ $? -eq 1 ]; then
        return
    fi

    # Parse to get the correct database source
    local CHOSEN_INDEX=$(( $(echo "$SOURCE_INDEX"| sed 's/)//') - 1 ))
    local DB_SOURCE="${SOURCES_ARRAY[$CHOSEN_INDEX]}"

    # Try to get database size. If source is custom, ask to enter URL.
    local FILE_SIZE
    local LAST_UPDATED="unknown"
    if [ "$DB_SOURCE" == "$DEFAULT_SOURCE" ]; then
        # For now this functionality doesn't work
        :
        #local JSON_OUTPUT=$(curl -k -H "Content-Type: application/json" -m 4 -f -s https://x-vps.com/index.php 2>/dev/null)
        #FILE_SIZE=$(echo "$JSON_OUTPUT" | jq -r .file_size)
        #LAST_UPDATED=$(echo "$JSON_OUTPUT" | jq -r .last_updated)
    elif [ "$DB_SOURCE" == "Custom" ]; then
        DB_SOURCE=$(whiptail --inputbox "Choose a source where to download the snapshot state DB from:" 8 $WIDTH "" --title "Select Custom Database Source" 3>&1 1>&2 2>&3)
        if [ $? -eq 1 ]; then
            return
        fi
    fi

    if [[ -z "${DB_SOURCE// }" ]] || [[ "x${DB_SOURCE}" == "x" ]]
    then
        whiptail --title "Empty source!" \
                 --msgbox "You didn't supply any source!" \
                 8 $WIDTH
        return
    fi

    # Try to get the file size before download
    [ -z "$FILE_SIZE" ] && { FILE_SIZE=$(wget --spider "$DB_SOURCE" 2>&1 | grep "^Length: " | sed 's/^.* (\(.*\)) .*$/\1/'); }
    [ -z "$FILE_SIZE" ] && FILE_SIZE="unknown"

    if (whiptail --title "Confirm DB Download" \
                 --yesno "Download new database from '$DB_SOURCE'?\n\nUpdated: ${LAST_UPDATED}, size: ${FILE_SIZE}\n\n(TIP: for long running tasks consider running hornetc in a screen session)" \
                 16 $WIDTH) then
        # This command will stop hornet, remove older database directories,
        # extract the database (on the fly) set correct user ownership and start HORNET up again.
        echo "Stopping hornet first, removing old database files and commencing download/extract of database files ..."
        systemctl stop hornet \
          && rm -rf /var/lib/hornet/mainnetdb* \
          && mkdir -p /var/lib/hornet/mainnetdb \
          && cd /var/lib/hornet \
          && wget -N "$DB_SOURCE" \
          && chown hornet.hornet /var/lib/hornet -RL \
          && systemctl start hornet

        if [[ $? -ne 0 ]]; then
            whiptail --title "New DB Failed!" \
                     --msgbox "Well this is embarrassing. Downloading the new DB failed..." \
                     8 $WIDTH
            # Cleanup any leftovers
            rm -rf /var/lib/hornet/mainnetdb* /var/lib/hornet/*.bin
            clear
            return 1
        else
            pause "Done! Please check HORNET's status and logs to verify it is error free."
            clear
        fi
    fi
}

## HORC
function get_latest_horc_version() {
    local RAND=$(echo -n $(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 7 | head -n 1))
    curl -s -f -m 5 -H 'Cache-Control: no-cache' "https://raw.githubusercontent.com/nuriel77/hornet-playbook/${HORC_BRANCH}/roles/hornet/files/horc?nocache=$RAND"|grep ^VERSION|cut -d= -f2
}

function check_new_horc() {
    local CURR_VERSION="$__VERSION__"
    local HORC_VERSION=$(get_latest_horc_version 2>&1)
    if [[ $? -ne 0 ]] || [[ "$HORC_VERSION" == "" ]]; then
        return 1
    fi

    if compare_versions $CURR_VERSION '>=' $HORC_VERSION; then
        return 1
    else
        return 0
    fi
}

function update_horc() {
    local HORC_VERSION=$(get_latest_horc_version 2>&1)
    local CURR_VERSION="$__VERSION__"
    if [[ $? -ne 0 ]] || [[ "$HORC_VERSION" == "" ]]; then
        whiptail --title "HORC Update Failed" \
                 --msgbox "Failed to get HORC version from github." \
                 8 $WIDTH
        return 1
    fi

    if compare_versions $CURR_VERSION '>=' $HORC_VERSION; then
        if ! (whiptail --title "No Updates" \
                     --yesno "You already have the latest version: ${CURR_VERSION}.\nDo you want to proceed anyway?" \
                     --defaultno \
                     10 $WIDTH) then
            return
        else
            # Don't need another confirmation question
            local NO_CONFIRM=1
            # Delete any 'completed' files for this version
            # This forces to re-run updates specific for
            # this version if any.
            rm -f "custom_updates/${CURR_VERSION}_updates.sh.completed"
        fi
    fi

    if [ -z "$NO_CONFIRM" ]; then
        if ! (whiptail --title "Confirm Update" \
                     --yesno "Are you sure you want to update HORC from '$__VERSION__' to '$HORC_VERSION'?" \
                     8 $WIDTH) then
            return
        fi
    fi

    # Verifies and pull latest changes
    verify_playbook
    if [[ $? -ne 0 ]]; then
         whiptail --title "Error!" \
                  --msgbox "ERROR: playbook task failed." \
                  8 $WIDTH
         return 1
    fi

    # Run playbook script upgrades
    cd /opt/hornet-playbook && ansible-playbook -i inventory site.yml -v --tags=scripts
    [[ $? -ne 0 ]] && MSG="Updating HORC failed!!! Check output above for errors." || MSG="Update finished successfully! Additional updates may apply upon restart of horc."
    pause "$MSG Press ENTER to return to menu."
    clear

    # Remove current pid file and restart
    rm -f "$PID_FILE"
    exec "$0"
}

# Used by sort_func to sort an array
# based on versions.
function version_sort() {
    local FIRST_VERSION=$(basename "$1" | cut -d_ -f1)
    local SECOND_VERSION=$(basename "$2" | cut -d_ -f1)
    local EVAL_STR='<'

    local GET_BOOL=$(python -c "from distutils.version import StrictVersion; print(StrictVersion('$FIRST_VERSION') $EVAL_STR StrictVersion('$SECOND_VERSION'))")
    if [[ "$GET_BOOL" == "True" ]]
    then
        return 0
    elif [[ "$GET_BOOL" == "False" ]]
    then
        return 1
    fi
}

# Generic sort version. Will accept a
# function that is supposed to return
# 0 or 1 for sorting
function sort_func() {
    (($#<=1)) && return 0
    local compare_func=$1
    shift
    local stack=( 0 $(($#-1)) ) beg end i pivot smaller larger
    UPDATES_SORTED=("$@")
    while ((${#stack[@]})); do
        beg=${stack[0]}
        end=${stack[1]}
        stack=( "${stack[@]:2}" )
        smaller=() larger=()
        pivot=${UPDATES_SORTED[beg]}
        for ((i=beg+1;i<=end;++i))
        do
            if "$compare_func" "${UPDATES_SORTED[i]}" "$pivot"
            then
                smaller+=( "${UPDATES_SORTED[i]}" )
            else
                larger+=( "${UPDATES_SORTED[i]}" )
            fi
        done
        UPDATES_SORTED=( "${UPDATES_SORTED[@]:0:beg}" "${smaller[@]}" "$pivot" "${larger[@]}" "${UPDATES_SORTED[@]:end+1}" )
        if ((${#smaller[@]}>=2));
        then
            stack+=( "$beg" "$((beg+${#smaller[@]}-1))" )
        fi
        if ((${#larger[@]}>=2))
        then
            stack+=( "$((end-${#larger[@]}+1))" "$end" )
        fi
   done
}

function run_custom_updates(){
    # Find pending update files
    readarray -t TO_RUN_UPDATES < <(find /opt/hornet-playbook/custom_updates/ -maxdepth 1 -type f -name '*_updates.sh')

    # Return if nothing to update
    ((${#TO_RUN_UPDATES[@]} == 0)) && { clear; return; }

    echo "Checking if any pending updates ..."
    # Sort updates by version from small to great
    sort_func version_sort "${TO_RUN_UPDATES[@]}"

    for _UPDATE in "${UPDATES_SORTED[@]}"
    do
        if [ ! -e "${_UPDATE}.completed" ]
        then
            echo "Executing update $(basename ${_UPDATE}) ..."
            if ! /bin/bash "$_UPDATE"
            then
                whiptail --title "Error!" \
                         --msgbox "ERROR: custom updates task failed at '$_UPDATE'." \
                         8 $WIDTH
                return 1
            else
                touch "${_UPDATE}.completed"
            fi
        else
            echo "$(basename ${_UPDATE}) already updated. To force rerun this update remove the file '$(pwd)/${_UPDATE}' and rerun horc."
        fi
    done

    clear
}

### Configs ###
function choose_editor() {
    USER_CHOICE=$(whiptail --inputbox "Choose a default text editor:" 8 $WIDTH ${EDITOR} --title "Choose Editor" 3>&1 1>&2 2>&3)
    if [[ $? -ne 0 ]]; then
        return
    fi

    which $USER_CHOICE >/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Invalid editor or editor not found on system." \
                 8 $WIDTH
        return 1
    fi

    EDITOR=$USER_CHOICE
    if ! grep -q "^export EDITOR" $HOME/.horc; then
        echo "export EDITOR=${EDITOR}" >> $HOME/.horc
    else
        sed -i "s/^export EDITOR=.*/export EDITOR=${EDITOR}/g" $HOME/.horc
    fi
}

function edit_config_file() {
    local CONFIG=$1
    local SERVICE=$2
    local RELOAD=$3

    BEFORE_EDIT=$(md5sum $CONFIG | awk {'print $1'})
    $EDITOR ${CONFIG}
    AFTER_EDIT=$(md5sum $CONFIG | awk {'print $1'})

    if [[ "$AFTER_EDIT" != "$BEFORE_EDIT" ]]; then
        if (whiptail --title "File Modified" \
                     --yesno "${CONFIG} file was modified.\n${SERVICE} requires a restart to pick up the new changes.\nDo you want to restart it now?" \
                     8 $WIDTH) then
            if [[ -z ${RELOAD} ]]; then
                service_cmd $SERVICE restart
            else
                service_cmd $SERVICE reload
            fi
        fi
    fi
}

function edit_config() {
    local CONFIG_FILE=$1
    local SERVICE=$2
    local RELOAD=$3
    if [ ! -f "$CONFIG_FILE" ]; then
        whiptail --title "Missing File" \
                 --msgbox "Error: cannot find '$CONFIG_FILE'" \
                 8 $WIDTH
        return 1
    fi

    # Make backup for restores
    if [ ! -f "${CONFIG_FILE}.original" ]; then
        cp -- "${CONFIG_FILE}" "${CONFIG_FILE}.original"
    fi

    if edit_config_file "${CONFIG_FILE}" "${SERVICE}" "${RELOAD}"; then
        return 0
    else
        return 1
    fi
}

### Neighbors ###
function add_neighbors() {
    local NEIGHBORS
    local HEIGHT
    local NBCTL_OUTPUT
    local RC
    local HORNET_CONFIG

    NEIGHBORS=$(whiptail --inputbox "Enter a list of neighbors separated by space:" 8 $WIDTH --title "Add Neighbors" 3>&1 1>&2 2>&3)
    RC=$?
    if [[ $RC -ne 0 ]]; then
        return
    fi

    ADD_LIST=$(echo "$NEIGHBORS" | sed 's/  */ /g' | sed 's/ / -n /g' | sed 's/^\(.*\)/-n \1/')
    if [[ "$ADD_LIST" != *[:ascii:]* ]]; then
        whiptail --title "Invalid Input" \
                 --msgbox "Invalid input provided. Please check the syntax you provided is valid." \
                  8 $WIDTH
        return
    fi

    HEIGHT=$(expr $(echo "$NEIGHBORS"|tr ' ' '\n'|wc -l) + 8)
    NEIGHBORS_TO_ADD=$(echo "$NEIGHBORS"|tr ' ' '\n')
    if (whiptail --title "Add Neighbors" \
                 --yesno "The following neighbor(s) will be added:\n\n$NEIGHBORS_TO_ADD" \
                 $HEIGHT $WIDTH) then

        # Set hornet config file if any configured
        HORNET_CONFIG=$(grep ^file /root/.nbctl | cut -d: -f2)
        [ -n "$HORNET_CONFIG" ] && HORNET_CONFIG="-f $HORNET_CONFIG"

        # Run nbctl command
        NBCTL_OUTPUT=$(nbctl -a $ADD_LIST $HORNET_CONFIG --hornet 2>&1)
        RC=$?
        if [[ $RC -eq 0 ]]; then
            HEIGHT=$(expr $(echo "$NBCTL_OUTPUT"|wc -l) + 7)
            whiptail --title "Added Neighbors" \
                     --msgbox "$NBCTL_OUTPUT" \
                    $HEIGHT $WIDTH
        else
            if echo "$NBCTL_OUTPUT" | grep -q "urllib2.URLError" ; then
               NBCTL_OUTPUT="Failed to communicate with HORNET API port. Check if HORNET is active and if $HOME/.nbctl is configured correctly."
            fi
            HEIGHT=$(expr $(echo "$NBCTL_OUTPUT"|wc -l) + 10)
            whiptail --title "Adding Neighbors Failed" \
                     --msgbox "Failure: $NBCTL_OUTPUT" \
                     $HEIGHT $WIDTH
        fi
    fi
}

function remove_neighbors() {
    local NEIGHBORS_ARRAY
    local NEIGHBORS
    local NEIGHBOR
    local HEIGHT
    local HORNET_CONFIG

    echo "Getting neighbors list..."
    NEIGHBORS=$(list_neighbors get | awk '{$1=$1}{print}' | tr -d ' ')
    RC=$?
    clear
    if [[ $RC -ne 0 ]]; then
        whiptail --title "Neighbors Failed" \
                 --msgbox "Failed to get list of neighbors: $NEIGHBORS" \
                 8 $WIDTH
        return
    fi
    if [ "$NEIGHBORS" == "" ]; then
        whiptail --title "No Neighbors" \
                 --msgbox "There are no neighbors configured" \
                 8 $WIDTH
        return
    fi
    HEIGHT=$(expr $(echo "$NEIGHBORS"|wc -l) + 5)
    NEIGHBORS_ARRAY=($(echo "$NEIGHBORS"))
    local NEIGHBORS_ARRAY_INDEXED=($(echo "$NEIGHBORS" | awk '!/^ / && NF { print NR")"; print $1$2$3}'))
    local NEIGHBOR_INDEX=$(whiptail --title "Remove neighbors" --menu "Choose a neighbor" 25 $WIDTH 16  "${NEIGHBORS_ARRAY_INDEXED[@]}" 3>&1 1>&2 2>&3)
    if [ $? -eq 1 ]; then
        return
    fi

    local NEIGHBOR_INX=$(echo "$NEIGHBOR_INDEX" | cut -d')' -f1)
    local NEIGHBOR_INX=$(expr $NEIGHBOR_INX - 1)
    local TO_REMOVE="${NEIGHBORS_ARRAY[$NEIGHBOR_INX]}"
    local SCHEME=$(echo "$TO_REMOVE"|cut -d'/' -f2|cut -d '|' -f1)
    local ADDRESS=$(echo "$TO_REMOVE"|cut -d'/' -f1)
    local DOMAIN="($(echo "$TO_REMOVE" | cut -d '|' -f2))"
    [[ "$DOMAIN" == "(null)" ]] && DOMAIN=""

    if (whiptail --title "Confirm removal" \
                 --yesno "Are you sure you want to remove:\n\n${SCHEME}://${ADDRESS} ${DOMAIN}" \
                 --defaultno \
                 12 $WIDTH)
    then
        HORNET_CONFIG=$(grep ^file /root/.nbctl | cut -d: -f2)
        [ -n "$HORNET_CONFIG" ] && HORNET_CONFIG="-f $HORNET_CONFIG"
        REMOVAL_OUTPUT=$(nbctl -r -n "${SCHEME}://${ADDRESS}" $HORNET_CONFIG --hornet 2>&1)
        if [ $? -eq 0 ];then
            whiptail --title "Removed successfully" \
                     --msgbox "$REMOVAL_OUTPUT" \
                     12 $WIDTH
        else
            HEIGHT=$(expr $(echo "$REMOVAL_OUTPUT"|wc -l) + 7)
            whiptail --title "Remove failed!" \
                     --msgbox "${REMOVAL_OUTPUT}" \
                     $HEIGHT $WIDTH
        fi
    fi
}

function list_neighbors() {
    local NEIGHBORS_QUERY
    local NEIGHBORS
    local HEIGHT
    local RETURN_RES=$1

    NEIGHBORS_QUERY=$(nbctl -l 2>&1)
    RC=$?
    if [[ $RC -ne 0 ]]; then
        if echo "$NEIGHBORS_QUERY" | egrep -q "urllib..URLError|timeout|refused" ; then
            NEIGHBORS_QUERY="Failed to communicate with HORNET API port. Check if HORNET is active and if $HOME/.nbctl is configured correctly."
        else
            NEIGHBORS_QUERY="Unknown error"
        fi
        if [ -n "$RETURN_RES" ]; then
            echo "$NEIGHBORS_QUERY"
            return 1
        fi
        HEIGHT=$(expr $(echo "$NEIGHBORS_QUERY"|wc -l) + 7)
        whiptail --title "List neighbors failed" \
                 --msgbox "$NEIGHBORS_QUERY" \
                 $HEIGHT $WIDTH
        return 1
    else
        NEIGHBORS=$(echo "$NEIGHBORS_QUERY" | jq -r '.neighbors[] | "\(.address)/\(.connectionType) | \(.domain)"' | column -c 80 -t)
        if [ -n "$RETURN_RES" ]; then
            echo "$NEIGHBORS"
            return 0
        fi

        if [ "$NEIGHBORS" == "" ]; then
            LENGTH=0
        else
            LENGTH=$(echo "$NEIGHBORS"|wc -l)
            FOR_WINDOW_LENGTH=$(($(echo "$NEIGHBORS"|wc -l)*2))
        fi
        local HEIGHT=$(expr $FOR_WINDOW_LENGTH + 8)
        whiptail --title "List Neighbors" \
                 --msgbox "Total: ${LENGTH} neighbor(s)\n\n${NEIGHBORS}" \
                 $HEIGHT $WIDTH
    fi
}

### Node info ###
function show_lmsi() {
    if [ ! -f "$HOME/.nbctl" ]; then
        whiptail --title "Missing .nbctl" \
                 --msgbox "Error: cannot find $HOME/.nbctl" \
                 8 $WIDTH
        return
    fi
    HORNET_HOST=$(grep ^host "$HOME/.nbctl" | cut -d: -f2-)
    local HORNET_API_VERSION=$(grep ^api_version $HOME/.nbctl | cut -d: -f2-)
    local LSMI_LOCAL=$(curl -f -m 5 -s $HORNET_HOST -X POST -H "X-IOTA-API-Version: $HORNET_API_VERSION" -H 'Content-Type: application/json' -d '{"command": "getNodeInfo"}'| python -m json.tool|egrep "latestSolidSubtangleMilestoneIndex|latestMilestoneIndex"| sed 's/,//'|sed -e 's/^[ \t]*//'|sed 's/"//g')
    if [ $? -ne 0 ]; then
        whiptail --title "Query failed" \
                 --msgbox "Error: failed query ${LSMI_LOCAL}. Check if HORNET is active and if $HOME/.nbctl is configured properly." \
                 12 $WIDTH
        return
    fi

    local LSMI_QUERY=$(curl -H 'Cache-Control: no-cache' -s -f -m 5 https://x-vps.com/lmsi|jq -r .latestMilestoneIndex 2>/dev/null)
    if [ $? -eq 0 ]; then
        OUTPUT="Latest milestone index: ${LSMI_QUERY}\n\n"
    else
        OUTPUT=""
    fi
    OUTPUT="${OUTPUT}Local:\n\n${LSMI_LOCAL}"
    whiptail --title "LatestMilestoneIndex" \
             --msgbox "$OUTPUT" \
             12 $WIDTH
}

function get_node_info() {
    if [ ! -f $HOME/.nbctl ]; then
        whiptail --title "Missing .nbctl" \
                 --msgbox "Error: cannot find $HOME/.nbctl" \
                 8 $WIDTH
        return
    fi
    local HORNET_HOST=$(grep ^host $HOME/.nbctl | cut -d: -f2-)
    local HORNET_API_VERSION=$(grep ^api_version $HOME/.nbctl | cut -d: -f2-)
    NODE_INFO=$(curl -f -m 5 -s $HORNET_HOST -X POST -H "X-IOTA-API-Version: $HORNET_API_VERSION" -H 'Content-Type: application/json' -d '{"command": "getNodeInfo"}'| jq -r 'to_entries[] | "\(.key): \(.value )"' | column -t | sort)
    if [ $? -ne 0 ]; then
        whiptail --title "Query failed" \
                 --msgbox "Error: failed query ${NODE_INFO}. Check if HORNET is active and if $HOME/.nbctl is configured properly." \
                 12 $WIDTH
        return
    fi

    HEIGHT=$(expr $(echo "$NODE_INFO"|wc -l) + 13)
    whiptail --title "Node Info" \
             --msgbox "$NODE_INFO" \
             $HEIGHT $WIDTH
}

### PS MEM ###
function view_ps_mem() {
    which ps_mem >/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
         whiptail --title "Missing ps_mem" \
         --msgbox "Error: cannot find 'ps_mem' utility!" \
         8 $WIDTH
         return 1
    fi

    whiptail --title "ps_mem utility" \
             --msgbox "This utility shows a per-process total memory usage.\nUse arrows or page up/down to scroll and q to exit." \
             8 $WIDTH
    ps_mem 2>/dev/null|less
}

### Services ###
function service_status() {
    local SERVICE
    SERVICE=$1
    # Pipe to less as some distros don't use pager
    systemctl status $SERVICE|less
}

function service_cmd() {
    local SERVICE
    local COMMAND
    local OUTPUT
    local EXTRA_CMD
    local DISABLE
    local STATE
    SERVICE=$1
    COMMAND=$2
    EXTRA_CMD=$3

    echo "Running 'systemctl $COMMAND $SERVICE' ..."
    if [ "$EXTRA_CMD" == "disable" ]; then
        systemctl disable $SERVICE
        STATE="and disable"
    elif [ "$EXTRA_CMD" == "enable" ]; then
        systemctl enable $SERVICE
        STATE="enabled"
    fi

    if [ "$EXTRA_CMD" != "enable" ]; then
        OUTPUT=$(systemctl $COMMAND $SERVICE 2>&1)
    else
        OUTPUT=""
    fi
    HEIGHT=$(expr $(echo "$OUTPUT"|wc -l) + 7)
    if [ $? -ne 0 ]; then
        whiptail --title "Failed" \
                 --msgbox "$COMMAND $SERVICE failed: $OUTPUT" \
                 $HEIGHT 48
    else
        whiptail --title "Success" \
                 --msgbox "$COMMAND $SERVICE $STATE OK" \
                 $HEIGHT 48
    fi
    clear
}

function service_log() {
    local SERVICE
    local ARGS
    SERVICE=$1
    # Pipe to less in the case too few lines.
    # This will prevent immediately exiting the view
    journalctl -u $SERVICE|less
}

function service_menu() {
    local SERVICE
    SERVICE=$1
    whiptail --title "HORC v${__VERSION__} - $SERVICE Service" \
             --menu "For logs use SHIFT-g to skip to end of log, or q to exit." \
             --cancel-button "Back" \
             25 $WIDTH 16 \
    "a)" "Status" \
    "b)" "Start" \
    "c)" "Stop" \
    "d)" "Restart" \
    "e)" "Disable start on reboot" \
    "f)" "Enable start on reboot" \
    "g)" "View log" \
    3>&1 1>&2 2>&3
}

function service() {
    local SERVICE
    local CHOICE
    SERVICE=$1
    CHOICE=$(service_menu $SERVICE)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi
    case "$CHOICE" in

        "a)")
            service_status $SERVICE
            service $SERVICE
            ;;

        "b)")
            service_cmd $SERVICE start
            service $SERVICE
            ;;

        "c)")
            service_cmd $SERVICE stop
            service $SERVICE
            ;;

        "d)")
            service_cmd $SERVICE restart
            service $SERVICE
            ;;

        "e)")
            service_cmd $SERVICE stop disable
            service $SERVICE
            ;;

        "f)")
            service_cmd $SERVICE "" enable
            service $SERVICE
            ;;

        "g)")
            service_log $SERVICE
            service $SERVICE
            ;;

        *)
            service $SERVICE
            ;;
    esac
}

function services_menu() {
    whiptail --title "HORC v${__VERSION__} - Node Services" \
             --menu "Choose an option" \
             --cancel-button "Back" \
             15 $WIDTH 8 \
    "a)" "Hornet" \
    "b)" "Nginx" \
    "c)" "HAproxy" \
    3>&1 1>&2 2>&3
}

function services() {
    local CHOICE
    CHOICE=$(services_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi
    case "$CHOICE" in

        "a)")
            service hornet
            services
            ;;

        "b)")
            service nginx
            services
            ;;

        "c)")
            service haproxy
            services
            ;;

        *)
           services
           ;;
    esac
}

### Rerun playbook installation ###
function rerun_playbook() {

    if (whiptail --title "Rerun Playbook Method" \
                 --yesno "Sometimes you may want to rerun the entire installation if you think something has changed and you want to try to reset the node to its initial state.\nThere are two options:\n\n1. simply rerun the installation\n2. use the override method: it will reset any configurations you may have configured manually.\n\nIf you would like to use the override method choose Yes else choose No for normal rerun.\n" \
                 --defaultno \
             18 $WIDTH) then
        local OVERWRITE=yes
    else
        local OVERWRITE=no
    fi

    if ! (whiptail --title "Rerun Playbook Confirm" \
                   --yesno "This option will allow you to rerun the entire installation.\nUsing override method: $OVERWRITE\n\nWould you like to proceed?\n" \
                   --defaultno \
          12 $WIDTH) then
        return
    fi

    verify_playbook
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Cannot rerun Hornet installation, unknown error." \
                 8 $WIDTH
        return 1
    fi
    cd /opt/hornet-playbook && ansible-playbook -i inventory site.yml -v -e "overwrite=$OVERWRITE"
    [[ $? -ne 0 ]] && MSG="Rerunning the playbook installation failed!!! Check output above for errors." || MSG="Rerun finished successfully!"
    pause "$MSG Press ENTER to return to menu."
    clear
}

### Clean Dangling Images ###
function remove_dangling_images() {
    local DANGLING_IMAGES
    DANGLING_IMAGES=($(/usr/bin/docker images -f "dangling=true" -q))
    if [[ ${#DANGLING_IMAGES[@]} -gt 0 ]]; then
        /usr/bin/docker rmi -f $(/usr/bin/docker images -f "dangling=true" -q)
        return $?
    fi
}

### Cleanup Docker Images ###
function cleanup_docker_images() {
    if (whiptail --title "Cleanup Docker Images" \
                 --yesno "To free up some diskspace you can delete unused docker images and volumes. For services that are temporarily off this isn't a problem: the image will be pulled again once you start up the service.\n\nWould you like proceed?" \
                 --defaultno \
                 14 $WIDTH) then
        echo "Removing unused volumes, please wait..."
        /usr/bin/docker volume prune -f

        echo "Removing unused images, please wait..."
        /usr/bin/docker image prune -a -f

        echo "Removing dangling images, please wait..."
        remove_dangling_images
        [[ $? -ne 0 ]] && MSG="Failed to cleanup unused images! Check output above for errors. " || MSG="Cleanup finished successfully! "
        pause "${MSG}Press ENTER to return to menu."
        clear
    fi
}

### IRITop ###
function view_iritop() {
    which iritop >/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
         whiptail --title "Missing iritop" \
         --msgbox "Error: cannot find 'iritop' utility!" \
         8 $WIDTH
         return 1
    fi

    iritop
}

### Notice ###
function how_to_setup() {
    whiptail --title "HORC v${VERSION} - Instructions" \
             --msgbox "Check that you have the .nbctl file in your home folder (ls -l ~/.nbctl).\nExample of the file's contents:\n\napi_version: 1\nhost: http://127.0.0.1:14265\nfile: /var/lib/hornet/neighbors.json\n\nThis will allow this script to use the nbctl utility to manage neighbors and get the node's data." \
             15 $WIDTH
}

### Configure files ###
function configure_files_menu() {
    whiptail --title "HORC v${__VERSION__} - Configure Files" \
             --menu "Choose an option" \
             --cancel-button "Back" \
              22 48 12 \
    "a)" "Hornet System Config" \
    "b)" "Hornet Main Config" \
    "c)" "Hornet Neighbors Config" \
    "d)" "Hornet MQTT Config" \
    "e)" "HAProxy Config" \
    "Z)" "Choose Editor" \
    3>&1 1>&2 2>&3
}

function configure_files() {
    local CHOICE
    CHOICE=$(configure_files_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi

    case "$CHOICE" in
        "a)")
            edit_config "$SYSCONFIG_FILE" "hornet"
            configure_files
            ;;

        "b)")
            edit_config "/var/lib/hornet/config.json" "hornet"
            configure_files
            ;;

        "c)")
            edit_config "/var/lib/hornet/neighbors.json" "hornet"
            configure_files
            ;;

        "d)")
            edit_config "/var/lib/hornet/mqtt_config.json" "hornet"
            configure_files
            ;;

        "e)")
            edit_config "/etc/haproxy/haproxy.cfg" "haproxy" "reload"
            configure_files
            ;;

        "Z)")
            choose_editor
            configure_files
            ;;

        *)
            configure_files
            ;;
    esac

}

### Hornet Plugins ###
function hornet_plugins() {
    local RESULTS=
    local ORIGINAL_NODE_OBJ=
    local NEW_NODE_OBJ=
    local JSON_OUTPUT=
    local CONFIG_FILE=

    # By default list all the existing plugins as disabled
    export ENABLE_PLUGINS=""
    export DISABLE_PLUGINS="Spammer,ZeroMQ,Monitor,MQTT"

    CONFIG_FILE=$(grep ^base_config "$HOME/.nbctl" | awk {'print $2'})

    # Save current config state
    ORIGINAL_NODE_OBJ=$(jq -r '.node | "\(.enableplugins) \(.disableplugins)"' < "$CONFIG_FILE")

    IFS=', ' read -r -a DISABLE_PLUGINS_ARRAY <<< "$DISABLE_PLUGINS"

    # Get current states (TODO: use associative array and loop)
    if jq -e -r '.node.enableplugins | index("Spammer")' < "$CONFIG_FILE" >/dev/null
    then
        PLUGIN_SPAMMER_STATE="ON"
    else
        PLUGIN_SPAMMER_STATE="OFF"
    fi

    if jq -e -r '.node.enableplugins | index("ZeroMQ")' < "$CONFIG_FILE" >/dev/null
    then
        PLUGIN_ZMQ_STATE="ON"
    else
        PLUGIN_ZMQ_STATE="OFF"
    fi

    if jq -e -r '.node.enableplugins | index("Monitor")' < "$CONFIG_FILE" >/dev/null
    then
        PLUGIN_TANGLEMONITOR_STATE="ON"
    else
        PLUGIN_TANGLEMONITOR_STATE="OFF"
    fi

    if jq -e -r '.node.enableplugins | index("MQTT")' < "$CONFIG_FILE" >/dev/null
    then
        PLUGIN_MQTT_STATE="ON"
    else
        PLUGIN_MQTT_STATE="OFF"
    fi


    RESULTS=$(whiptail --title "HORC v${__VERSION__} - Plugins" \
        --checklist \
        --cancel-button "Exit" \
        "\nPlease choose plugins to enable or disable.\n\
Select/unselect options using space and\nclick Enter to proceed.\n" 15 50 "${#DISABLE_PLUGINS_ARRAY[@]}" \
        "Spammer"           "...         Spammer" "$PLUGIN_SPAMMER_STATE" \
        "ZMQ"               "...         ZeroMQ" "$PLUGIN_ZMQ_STATE" \
        "MQTT"              "...         MQTT" "$PLUGIN_MQTT_STATE" \
        "Monitor"           "...         Tangle Monitor" "$PLUGIN_TANGLEMONITOR_STATE" \
        3>&1 1>&2 2>&3)

    RC=$?
    [[ $RC -ne 0 ]] && return

    read -a RESULTS_ARRAY <<< "$RESULTS"
    for CHOICE in "${RESULTS_ARRAY[@]}"
    do
        case $CHOICE in
            '"Spammer"')
                ENABLE_PLUGINS+=",Spammer"
                DISABLE_PLUGINS_ARRAY=("${DISABLE_PLUGINS_ARRAY[@]/Spammer/}")
                ;;
            '"ZMQ"')
                ENABLE_PLUGINS+=",ZeroMQ"
                DISABLE_PLUGINS_ARRAY=("${DISABLE_PLUGINS_ARRAY[@]/ZeroMQ/}")
                ;;
            '"MQTT"')
                ENABLE_PLUGINS+=",MQTT"
                DISABLE_PLUGINS_ARRAY=("${DISABLE_PLUGINS_ARRAY[@]/MQTT/}")
                ;;
            '"Monitor"')
                ENABLE_PLUGINS+=",Monitor"
                DISABLE_PLUGINS_ARRAY=("${DISABLE_PLUGINS_ARRAY[@]/Monitor/}")
                ;;
            *)
                ;;
        esac
    done

    DISABLE_PLUGINS=$(printf "%s,"  "${DISABLE_PLUGINS_ARRAY[@]}")
    JSON_OUTPUT=$(cat "$CONFIG_FILE" | python -c '
import json, sys, os
obj = json.load(sys.stdin)
enable_plugins = os.environ["ENABLE_PLUGINS"]
disable_plugins = os.environ["DISABLE_PLUGINS"]
obj["node"]["enableplugins"] = [p for p in enable_plugins.split(",") if p != ""]
obj["node"]["disableplugins"] = [p for p in disable_plugins.split(",") if p != ""]
print(json.dumps(obj))
')

    NEW_NODE_OBJ=$(jq -r '.node | "\(.enableplugins) \(.disableplugins)"' <<<"$JSON_OUTPUT")
    [[ "$ORIGINAL_NODE_OBJ" == "$NEW_NODE_OBJ" ]] && return

    if (whiptail --title "Restart Hornet" \
             --yesno "You've made changes to the plugins. A restart of HORNET is needed to load the new configuration.\n\nRestart now?" \
             --defaultno \
             10 $WIDTH) then
        jq . <<< "$JSON_OUTPUT" > "$CONFIG_FILE"
        /bin/systemctl restart hornet
    fi
}

### Neighbors ###
function neighbors_menu(){
    whiptail --title "HORC v${__VERSION__} - Neighbors" \
             --menu "Choose an option" \
             --cancel-button "Back" \
              12 48 4 \
    "a)" "Add Neighbors" \
    "b)" "Remove neighbors" \
    "c)" "List neighbors" \
    3>&1 1>&2 2>&3
}

function neighbors(){
    local CHOICE
    CHOICE=$(neighbors_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi

    case "$CHOICE" in
        "a)")
            add_neighbors
            neighbors
            ;;

        "b)")
            remove_neighbors
            neighbors
            ;;

        "c)")
            list_neighbors
            neighbors
            ;;

        *)
            neighbors
            ;;
    esac
}

### Main Menu ###
function main_menu() {
    local MENU="Choose an option"
    if check_new_horc; then
        MENU="${MENU}\n(*HORC update available)"
    fi

    if check_new_hornet; then
        MENU="${MENU}\n(*HORNET update available)"
    fi

    whiptail --title "HORC v${__VERSION__} - Hornet Configuration Menu" \
             --menu "$MENU" \
             --cancel-button "Exit" \
             26 $WIDTH 16 \
    "a)" "Update Hornet Software" \
    "b)" "Hornet Plugins" \
    "c)" "Manage Services" \
    "d)" "Configure Files" \
    "e)" "View Per Processes Memory Usage" \
    "f)" "Rerun Playbook Installation" \
    "g)" "Clean Unused Docker Images" \
    "h)" "Update HORC and node scripts" \
    "i)" "Enable HAProxy Access" \
    "j)" "Enable HTTPS / Certificate" \
    "k)" "Get Node Info" \
    "l)" "Show LatestMilestoneIndex" \
    "m)" "Get new snapshot DB" \
    "n)" "Neighbors" \
    "o)" "View IRITOP" \
    "Z)" "Configure this Script" \
    3>&1 1>&2 2>&3
}

function run_main_menu() {
    local CHOICE
    CHOICE=$(main_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        exit
    fi

    case "$CHOICE" in
        "Z)")
            how_to_setup
            run_main_menu
            ;;

        "a)")
            upgrade_hornet
            run_main_menu
            ;;

        "b)")
            hornet_plugins
            run_main_menu
            ;;

        "c)")
            services
            run_main_menu
            ;;

        "d)")
            configure_files
            run_main_menu
            ;;

        "e)")
            view_ps_mem
            run_main_menu
            ;;

        "f)")
            rerun_playbook
            run_main_menu
            ;;

        "g)")
            cleanup_docker_images
            run_main_menu
            ;;

        "h)")
            update_horc
            run_main_menu
            ;;

        "i)")
            enable_haproxy
            run_main_menu
            ;;

        "j)")
            enable_https
            run_main_menu
            ;;

        "k)")
            get_node_info
            run_main_menu
            ;;

        "l)")
            show_lmsi
            run_main_menu
            ;;

        "m)")
            get_db
            run_main_menu
            ;;

        "n)")
            neighbors
            run_main_menu
            ;;

        "o)")
            view_iritop
            run_main_menu
            ;;

        *)
            run_main_menu
            ;;
    esac
}

# Get OS and version
set_dist

# Run custom updates
run_custom_updates

# Run main menu
run_main_menu
