#!/usr/bin/env bash
set -o pipefail

# This is just a proof-of-concept. Use with care.
# Only use if you installed your node using hornet-playbook

if [[ $EUID -ne 0 ]]; then
   echo "This script must be run as root"
   echo "Please change to root: 'sudo su -' and re-run"
   exit 1
fi

clear

[ -f "$HOME/.horc" ] && . "$HOME/.horc"
[ -f "/opt/hornet-playbook/inventory-multi" ] && INVENTORY_FILE=inventory-multi || INVENTORY_FILE=inventory

: "${EDITOR:=nano}"

VERSION_TEMP=1.3.4
__VERSION__=${VERSION_TEMP}
SEMVER_REGEX="^(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)(\\-[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?(\\+[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?$"

: "${HORNET_BRANCH:=main}"
: "${HORC_BRANCH:=main}"
CUR_DIR="$(pwd)"

PID_FILE="/var/run/horc.pid"
WIDTH=78

# Source if exists
[ -f ~/.horc ] && . ~/.horc

export NEWT_COLORS='
window=,
'

# Check if another process of horc is already running.
if [ -e "$PID_FILE" ]
then
    PID_FROM_FILE=$(cat "$PID_FILE")
    if ps -fq $PID_FROM_FILE | grep -q "$(basename $0)$"
    then
        echo "ERROR: another instance of $(basename $0) is already running with pid ${PID_FROM_FILE}."
        exit 1
    fi
fi

# Cleanup function
function cleanup() {
    rm -f "$PID_FILE"
    cd "$CUR_DIR"
    trap - EXIT
    clear
}

# Write pid to pidfile
echo -n $$ >"$PID_FILE"

# Set exit trap
trap cleanup INT TERM EXIT

function pause(){
   read -p "$*"
   clear
}

# Get OS and Dist
function set_dist() {
    if [ -f /etc/os-release ]; then
        # freedesktop.org and systemd
        . /etc/os-release
        export OS=$NAME
        export VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
        # linuxbase.org
        export OS=$(lsb_release -si)
        export VER=$(lsb_release -sr)
    elif [ -f /etc/lsb-release ]; then
        # For some versions of Debian/Ubuntu without lsb_release command
        . /etc/lsb-release
        export OS=$DISTRIB_ID
        export VER=$DISTRIB_RELEASE
    elif [ -f /etc/debian_version ]; then
        # Older Debian/Ubuntu/etc.
        export OS=Debian
        export VER=$(cat /etc/debian_version)
    elif [ -f /etc/SuSe-release ]; then
        # Older SuSE/etc.
        echo "Unsupported OS."
        exit 1
    elif [ -f /etc/redhat-release ]; then
        # Older Red Hat, CentOS, etc.
        echo "Old OS version. Minimum required is 7."
        exit 1
    else
        # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
        export OS=$(uname -s)
        export VER=$(uname -r)
    fi

    # Set path to hornet's configuration file
    if [[ "$OS" =~ ^(CentOS|Red) ]]; then
        export SYSCONFIG_FILE=/etc/sysconfig/hornet
    elif [[ "$OS" =~ ^(Ubuntu|Debian|Raspbian) ]]; then
        export SYSCONFIG_FILE=/etc/default/hornet
    fi
}

function validate_version {
    local version=$1
    if [[ "$version" =~ $SEMVER_REGEX ]]
    then
        local major=${BASH_REMATCH[1]}
        local minor=${BASH_REMATCH[2]}
        local patch=${BASH_REMATCH[3]}
        local prere=${BASH_REMATCH[4]}
        local build=${BASH_REMATCH[5]}
        if [[ ! -z "$prere" ]] || [[ ! -z "$build" ]]
        then
            return 1
        fi
    else
        return 1
    fi
}

function compare_versions() {
    local FIRST_VERSION=$(echo "$1" | tr -d 'v')
    local EVAL_STR=$2
    local SECOND_VERSION=$(echo "$3" | tr -d 'v')

    for VER in "$FIRST_VERSION" "$SECOND_VERSION"
    do
        if ! validate_version "$VER"
        then
            >&2 echo "Warning: the version '$VER' is not a valid release version. Cannot check version." 
            return 1
        fi
    done

    local GET_BOOL=$(python -c "from distutils.version import StrictVersion; print(StrictVersion('$FIRST_VERSION') $EVAL_STR StrictVersion('$SECOND_VERSION'))")
    if [[ "$GET_BOOL" == "True" ]]
    then
        return 0
    elif [[ "$GET_BOOL" == "False" ]]
    then
        return 1
    fi
}

### Playbook ###
function verify_playbook() {
    local OUTPUT
    local HEIGHT
    local RC
    if [ ! -d /opt/hornet-playbook ]; then
        cd /opt && git clone -b "$HORC_BRANCH" https://github.com/nuriel77/hornet-playbook.git
    fi
    cd /opt/hornet-playbook

    OUTPUT=$(git pull 2>&1)
    RC=$?
    HEIGHT=$(expr $(echo "$OUTPUT"|wc -l) + 10)
    if [[ $RC -ne 0 ]]; then
        whiptail --title "Git Errors" \
                 --msgbox "Errors when trying to update the playbook repository: $OUTPUT" \
                 $HEIGHT $WIDTH
        return 1
    fi
}

function enable_https() {
    local SSL_EMAIL
    local SSL_DOMAIN

    if ! (whiptail --title "Enable HTTPS" \
                 --yesno "This option will request a certificate for this node via certbot/letsencrypt using nginx.\nA domain name must be configured pointing to this node's IP address.\n\nDo you want to proceed?" \
                 --defaultno \
                 14 $WIDTH) then
        return 1
    fi

    SSL_EMAIL=$(whiptail --inputbox "Enter your email address to register your TLS certificate with:" 8 $WIDTH --title "Enter Email" 3>&1 1>&2 2>&3)
    if [[ $? -ne 0 ]]; then
        return
    fi

    SSL_DOMAIN=$(whiptail --inputbox "Enter the domain name to register the TLS certificate with:" 8 $WIDTH --title "Enter FQDN" 3>&1 1>&2 2>&3)
    if [[ $? -ne 0 ]]; then
        return
    fi

    verify_playbook
    if [[ $? -ne 0 ]]; then
         whiptail --title "Error!" \
                  --msgbox "ERROR: Cannot enable HTTPS." \
                  8 $WIDTH
         return 1
    fi

    if ! (whiptail --title "Verify Details" \
          --yesno "You've entered email '${SSL_EMAIL}' and the domain '${SSL_DOMAIN}'\n\nIs this correct?" \
          --defaultno \
          12 $WIDTH) then
        return
    fi

    # Run the script to request a certificate
    /usr/local/bin/certbot-nginx.sh "${SSL_EMAIL}" "${SSL_DOMAIN}"
    if [[ $? -ne 0 ]]; then
        pause "SSL Certificate request failed. See output above for more details."
        clear
        return 1
    fi

    # Subsequent requests to create new certificates (for example, original
    # directory was wiped) certbot will start appending an index for path name
    # We need to make sure we find a directory.
    FULL_PATH=$(find /etc/letsencrypt/live -type d -name "${SSL_DOMAIN}*" -print -quit)

    # Will configure nginx to use the let's encrypt certificates
    if [ -f "${FULL_PATH}/cert.pem" ]; then
        if ! grep -q "^ssl_cert_file: ${FULL_PATH}/fullchain.pem" /opt/hornet-playbook/group_vars/all/z-ssl-override.yml >/dev/null 2>&1; then
            cat <<EOF >> /opt/hornet-playbook/group_vars/all/z-ssl-override.yml
ssl_cert_file: ${FULL_PATH}/cert.pem
ssl_key_file: ${FULL_PATH}/privkey.pem
ssl_bundle_cert: ${FULL_PATH}/fullchain.pem
create_selfsigned_cert: False
letsencrypt: True
EOF
        fi
        # We don't enable nginx with this common certificate in multi node setup!
        cd /opt/hornet-playbook && ansible-playbook -i inventory -v site.yml --tags=configure_nginx_ssl
    fi

    pause "Done. Check above output to see the status of the request."
    clear
}

### Hornet ###
function get_latest_hornet_commit {
    # Experimental/dev
    curl -H 'Cache-Control: no-cache' -s -m 5 -f "https://api.github.com/repos/gohornet/hornet/commits/$HORNET_BRANCH" | jq -r .sha | head -c 7
}

function get_latest_hornet_release {
    curl -H 'Cache-Control: no-cache' -s -m 5 -f https://api.github.com/repos/gohornet/hornet/releases/latest  | jq -r .tag_name | tr -d 'v'
}

function check_new_hornet {
    local HORNET_LATEST
    local HORNET_VERSION

    HORNET_LATEST=$(get_latest_hornet_release)
    HORNET_VERSION=$(grep ^TAG "$SYSCONFIG_FILE" | cut -d= -f2)

    if compare_versions $HORNET_VERSION '<' $HORNET_LATEST; then
        return 0
    else
        return 1
    fi
}

function upgrade_hornet() {
    echo "Checking for updates..."
    local HORNET_LATEST
    local HORNET_VERSION

    HORNET_LATEST=$(get_latest_hornet_release)
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Failed to get Hornet's latest version\n${HORNET_LATEST}" \
                 8 $WIDTH
        return 1
    fi
    clear

    HORNET_VERSION=$(grep ^TAG "$SYSCONFIG_FILE" | cut -d= -f2)
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Failed to get current Hornet's version!" \
                 8 $WIDTH
        return 1
    fi

    # Only use compare_versions if real versions (e.g. semver)
    if compare_versions $HORNET_VERSION '>=' $HORNET_LATEST; then
        if ! (whiptail --title "No Updates" \
                 --yesno "You already have the latest version: ${HORNET_VERSION}.\nDo you want to proceed anyway?" \
                 --defaultno \
                 10 $WIDTH) then
            return
        else
            local NO_CONFIRM=1
        fi
    fi

    if [ -z "$NO_CONFIRM" ]; then
        if ! (whiptail --title "Upgrade Hornet" \
                     --yesno "Are you sure you want to upgrade Hornet from ${HORNET_VERSION} to ${HORNET_LATEST}?\nWARNING: only do this if you know what your are doing!" \
                     --defaultno \
                     8 $WIDTH) then
            return
        fi
    fi

    verify_playbook
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Cannot upgrade Hornet." \
                 8 $WIDTH
        return 1
    fi

    echo "Upgrading Docker image.... (Hornet will automatically restart if image gets updated)"
    cd /opt/hornet-playbook && ansible-playbook -i inventory \
                                -v site.yml \
                                --tags=build_hornet_image

    if [[ $? -ne 0 ]]; then
         whiptail --title "Error!" \
                  --msgbox "ERROR: Failed upgrading Hornet." \
                  8 $WIDTH
         rm -f "$TFILE"
         return 1
    fi

    if ! docker ps -a | sed '1d' | awk {'print $2'} | grep -q "$HORNET_LATEST"
    then
        echo "Force update tag and restart hornet ..."
        sed -i "s/^TAG=.*$/TAG=$HORNET_LATEST/" "$SYSCONFIG_FILE"
        /bin/systemctl restart hornet
    fi

    pause "Update finished successfully. Nevertheless, it is recommended to check the status of Hornet. Press ENTER to return to menu."
    clear
}

### Get DB ###
function get_db() {
    local CONFIG_FILE

    CONFIG_FILE=$(grep ^base_config "$HOME/.nbctl" | awk {'print $2'})

    # Playbook's default sources
    SOURCES_ARRAY=($(jq -r '.snapshots.downloadURLs[] | .full' < "$CONFIG_FILE") "Custom")

    # Create an indexed array for building the menu
    SOURCES_ARRAY_INDEXED=($(printf "%s\n" "${SOURCES_ARRAY[@]}"| awk -F, '!/^ / && NF { print NR")"; print $1}'))

    # Output the menu
    SOURCE_INDEX=$(whiptail --title "Select DB Source" --menu "This action will download and boostrap a synced database.\nChoose a source where to download the database from:" 16 $WIDTH 4 "${SOURCES_ARRAY_INDEXED[@]}" 3>&1 1>&2 2>&3)
    if [ $? -eq 1 ]; then
        return
    fi

    # Parse to get the correct database source
    local CHOSEN_INDEX=$(( $(echo "$SOURCE_INDEX"| sed 's/)//') - 1 ))
    local DB_SOURCE="${SOURCES_ARRAY[$CHOSEN_INDEX]}"

    # Try to get database size. If source is custom, ask to enter URL.
    local FILE_SIZE
    local LAST_UPDATED="unknown"
    if [ "$DB_SOURCE" == "https://x-vps.com/export.bin" ]; then
        local JSON_OUTPUT=$(curl -k -H "Content-Type: application/json" -m 4 -f -s https://x-vps.com/index.php 2>/dev/null)
        FILE_SIZE=$(echo "$JSON_OUTPUT" | jq -r .file_size)
        LAST_UPDATED=$(echo "$JSON_OUTPUT" | jq -r .last_updated)
    elif [ "$DB_SOURCE" == "Custom" ]; then
        DB_SOURCE=$(whiptail --inputbox "Choose a source where to download the snapshot state DB from:" 8 $WIDTH "" --title "Select Custom Database Source" 3>&1 1>&2 2>&3)
        if [ $? -eq 1 ]; then
            return
        fi
    fi

    if [[ -z "${DB_SOURCE// }" ]] || [[ "x${DB_SOURCE}" == "x" ]]
    then
        whiptail --title "Empty source!" \
                 --msgbox "You didn't supply any source!" \
                 8 $WIDTH
        return
    fi

    # Try to get the file size before download
    [ -z "$FILE_SIZE" ] && { FILE_SIZE=$(wget --spider "$DB_SOURCE" 2>&1 | grep "^Length: " | sed 's/^.* (\(.*\)) .*$/\1/'); }
    [ -z "$FILE_SIZE" ] && FILE_SIZE="unknown"

    if (whiptail --title "Confirm DB Download" \
                 --yesno "Download new database from '$DB_SOURCE'?\n\nUpdated: ${LAST_UPDATED}, size: ${FILE_SIZE}\n\n" \
                 16 $WIDTH) then
        # This command will stop hornet, remove older database directories,
        # extract the database (on the fly) set correct user ownership and start HORNET up again.
        echo "Stopping hornet first, removing old database files and commencing download/extract of database files ..."
        systemctl stop hornet \
          && rm -rf /var/lib/hornet/snapshots /var/lib/hornet/mainnetdb/* \
          && mkdir -p /var/lib/hornet/mainnetdb \
          && mkdir -p /var/lib/hornet/snapshots/mainnet \
          && cd /var/lib/hornet/snapshots/mainnet \
          && wget -O full_snapshot.bin "$DB_SOURCE" \
          && chown hornet.hornet /var/lib/hornet -RL \
          && systemctl start hornet

        if [[ $? -ne 0 ]]; then
            whiptail --title "New DB Failed!" \
                     --msgbox "Well this is embarrassing. Downloading the new DB failed..." \
                     8 $WIDTH
            # Cleanup any leftovers
            rm -rf /var/lib/hornet/mainnetdb* /var/lib/hornet/snapshots/*
            chown hornet.hornet /var/lib/hornet -RL
            clear
            return 1
        else
            pause "Done! Please check HORNET's status and logs to verify it is error free."
            clear
        fi
    fi
}

## Set DB Max Size
function set_db_max_size() {
    local DB_MAX_SIZE_CURRENT
    local DB_MAX_SIZE_NEW

    if [[ $(jq -r .pruning.size.enabled < /var/lib/hornet/config.json) != true ]]
    then
        whiptail --title "DB Max Size Disabled!" \
                 --msgbox "Database size limit feature is disabled in hornet.conf!\nMake sure to enable it in order to be able to set Max Size." \
                 9 $WIDTH
        return
    fi

    DB_MAX_SIZE_CURRENT=$(jq -r .pruning.size.targetSize < /var/lib/hornet/config.json)
    _DB_MAX_SIZE_NEW=$(whiptail --inputbox "\nCurrent DB max size is set to ${DB_MAX_SIZE_CURRENT}.\nEnter a new size:" 10 $WIDTH "" --title "Select DB Max Size" 3>&1 1>&2 2>&3)
    if [ $? -eq 1 ]; then
        return
    elif [[ "$_DB_MAX_SIZE_NEW" == "" ]]; then
        whiptail --title "No Input" \
                 --msgbox "No size selected!" \
                 8 $WIDTH
        return
    fi

    DB_MAX_SIZE_NEW=$(tr -d " \t" <<< "$_DB_MAX_SIZE_NEW")
    if [[ "$DB_MAX_SIZE_NEW" == "$DB_MAX_SIZE_CURRENT" ]]
    then
        whiptail --title "No Change" \
                 --msgbox "You've selected the same max size as the currently configured max size." \
                 8 $WIDTH
        return
    fi

    if ! (whiptail --title "Confirm Update" \
                   --yesno "Are you sure you want to set DB Max Size to '$DB_MAX_SIZE_NEW'?" \
                   8 $WIDTH) then
        return
    fi

    echo "Updating Max Size ..."
    verify_playbook
    test -f /opt/hornet-playbook/group_vars/all/z-append.yml && sed -i '/^hornet_db_max_size:/d' /opt/hornet-playbook/group_vars/all/z-append.yml
    echo "hornet_db_max_size: $DB_MAX_SIZE_NEW" >> /opt/hornet-playbook/group_vars/all/z-append.yml
    run-playbook --tags=hornet_config_file -e overwrite=yes
}


## HORC
function get_latest_horc_version() {
    local RAND=$(echo -n $(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 7 | head -n 1))
    curl -s -f -m 5 -H 'Cache-Control: no-cache' "https://raw.githubusercontent.com/nuriel77/hornet-playbook/${HORC_BRANCH}/roles/hornet/files/horc?nocache=$RAND"|grep ^VERSION|cut -d= -f2
}

function check_new_horc() {
    local CURR_VERSION="$__VERSION__"
    local HORC_VERSION=$(get_latest_horc_version 2>&1)
    if [[ $? -ne 0 ]] || [[ "$HORC_VERSION" == "" ]]; then
        return 1
    fi

    if compare_versions $CURR_VERSION '>=' $HORC_VERSION; then
        return 1
    else
        return 0
    fi
}

function update_horc() {
    local HORC_VERSION=$(get_latest_horc_version 2>&1)
    local CURR_VERSION="$__VERSION__"
    if [[ $? -ne 0 ]] || [[ "$HORC_VERSION" == "" ]]; then
        whiptail --title "HORC Update Failed" \
                 --msgbox "Failed to get HORC version from github." \
                 8 $WIDTH
        return 1
    fi

    if compare_versions $CURR_VERSION '>=' $HORC_VERSION; then
        if ! (whiptail --title "No Updates" \
                     --yesno "You already have the latest version: ${CURR_VERSION}.\nDo you want to proceed anyway?" \
                     --defaultno \
                     10 $WIDTH) then
            return
        else
            # Don't need another confirmation question
            local NO_CONFIRM=1
            # Delete any 'completed' files for this version
            # This forces to re-run updates specific for
            # this version if any.
            rm -f "custom_updates/${CURR_VERSION}_updates.sh.completed"
        fi
    fi

    if [ -z "$NO_CONFIRM" ]; then
        if ! (whiptail --title "Confirm Update" \
                     --yesno "Are you sure you want to update HORC from '$__VERSION__' to '$HORC_VERSION'?" \
                     8 $WIDTH) then
            return
        fi
    fi

    # Verifies and pull latest changes
    verify_playbook
    if [[ $? -ne 0 ]]; then
         whiptail --title "Error!" \
                  --msgbox "ERROR: playbook task failed." \
                  8 $WIDTH
         return 1
    fi

    # Run playbook script upgrades
    cd /opt/hornet-playbook && ansible-playbook -i inventory site.yml -v --tags=scripts
    [[ $? -ne 0 ]] && MSG="Updating HORC failed!!! Check output above for errors." || MSG="Update finished successfully! Additional updates may apply upon restart of horc."
    pause "$MSG Press ENTER to return to menu."
    clear

    # Remove current pid file and restart
    rm -f "$PID_FILE"
    exec "$0"
}

# Used by sort_func to sort an array
# based on versions.
function version_sort() {
    local FIRST_VERSION=$(basename "$1" | cut -d_ -f1)
    local SECOND_VERSION=$(basename "$2" | cut -d_ -f1)
    local EVAL_STR='<'

    local GET_BOOL=$(python -c "from distutils.version import StrictVersion; print(StrictVersion('$FIRST_VERSION') $EVAL_STR StrictVersion('$SECOND_VERSION'))")
    if [[ "$GET_BOOL" == "True" ]]
    then
        return 0
    elif [[ "$GET_BOOL" == "False" ]]
    then
        return 1
    fi
}

# Generic sort version. Will accept a
# function that is supposed to return
# 0 or 1 for sorting
function sort_func() {
    (($#<=1)) && return 0
    local compare_func=$1
    shift
    local stack=( 0 $(($#-1)) ) beg end i pivot smaller larger
    UPDATES_SORTED=("$@")
    while ((${#stack[@]})); do
        beg=${stack[0]}
        end=${stack[1]}
        stack=( "${stack[@]:2}" )
        smaller=() larger=()
        pivot=${UPDATES_SORTED[beg]}
        for ((i=beg+1;i<=end;++i))
        do
            if "$compare_func" "${UPDATES_SORTED[i]}" "$pivot"
            then
                smaller+=( "${UPDATES_SORTED[i]}" )
            else
                larger+=( "${UPDATES_SORTED[i]}" )
            fi
        done
        UPDATES_SORTED=( "${UPDATES_SORTED[@]:0:beg}" "${smaller[@]}" "$pivot" "${larger[@]}" "${UPDATES_SORTED[@]:end+1}" )
        if ((${#smaller[@]}>=2));
        then
            stack+=( "$beg" "$((beg+${#smaller[@]}-1))" )
        fi
        if ((${#larger[@]}>=2))
        then
            stack+=( "$((end-${#larger[@]}+1))" "$end" )
        fi
   done
}

function run_custom_updates(){
    # Find pending update files
    readarray -t TO_RUN_UPDATES < <(find /opt/hornet-playbook/custom_updates/ -maxdepth 1 -type f -name '*_updates.sh')

    # Return if nothing to update
    ((${#TO_RUN_UPDATES[@]} == 0)) && { clear; return; }

    echo "Checking if any pending updates ..."
    # Sort updates by version from small to great
    sort_func version_sort "${TO_RUN_UPDATES[@]}"

    for _UPDATE in "${UPDATES_SORTED[@]}"
    do
        if [ ! -e "${_UPDATE}.completed" ]
        then
            echo "Executing update $(basename ${_UPDATE}) ..."
            if ! /bin/bash "$_UPDATE"
            then
                whiptail --title "Error!" \
                         --msgbox "ERROR: custom updates task failed at '$_UPDATE'." \
                         8 $WIDTH
                return 1
            else
                touch "${_UPDATE}.completed"
            fi
        else
            echo "$(basename ${_UPDATE}) already updated. To force rerun this update remove the file '${_UPDATE}.completed' and rerun horc."
        fi
    done

    clear
}

### Configs ###
function choose_editor() {
    USER_CHOICE=$(whiptail --inputbox "Choose a default text editor:" 8 $WIDTH ${EDITOR} --title "Choose Editor" 3>&1 1>&2 2>&3)
    if [[ $? -ne 0 ]]; then
        return
    fi

    which $USER_CHOICE >/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Invalid editor or editor not found on system." \
                 8 $WIDTH
        return 1
    fi

    EDITOR=$USER_CHOICE
    if ! grep -q "^export EDITOR" $HOME/.horc; then
        echo "export EDITOR=${EDITOR}" >> $HOME/.horc
    else
        sed -i "s/^export EDITOR=.*/export EDITOR=${EDITOR}/g" $HOME/.horc
    fi
}

function edit_config_file() {
    local CONFIG=$1
    local SERVICE=$2
    local RELOAD=$3

    BEFORE_EDIT=$(md5sum $CONFIG | awk {'print $1'})
    $EDITOR ${CONFIG}
    AFTER_EDIT=$(md5sum $CONFIG | awk {'print $1'})

    if [[ "$AFTER_EDIT" != "$BEFORE_EDIT" ]]; then
        if (whiptail --title "File Modified" \
                     --yesno "${CONFIG} file was modified.\n${SERVICE} requires a restart to pick up the new changes.\nDo you want to restart it now?" \
                     8 $WIDTH) then
            if [[ -z ${RELOAD} ]]; then
                service_cmd $SERVICE restart
            else
                service_cmd $SERVICE reload
            fi
        fi
    fi
}

function edit_config() {
    local CONFIG_FILE=$1
    local SERVICE=$2
    local RELOAD=$3
    if [ ! -f "$CONFIG_FILE" ]; then
        whiptail --title "Missing File" \
                 --msgbox "Error: cannot find '$CONFIG_FILE'" \
                 8 $WIDTH
        return 1
    fi

    # Make backup for restores
    if [ ! -f "${CONFIG_FILE}.original" ]; then
        cp -- "${CONFIG_FILE}" "${CONFIG_FILE}.original"
    fi

    if edit_config_file "${CONFIG_FILE}" "${SERVICE}" "${RELOAD}"; then
        return 0
    else
        return 1
    fi
}

### Peers ###
function add_peer() {
    local PEER
    local HEIGHT
    local NBCTL_OUTPUT
    local ADD_PEER
    local RC

    PEER=$(whiptail --inputbox "Enter a peer to add.\nThe format is:\n/dns/hostname/tcp/15600/p2p/peerID,alias/PeerAlias\ne.g: /dns/mynode.io/tcp/15600/p2p/12D3KooWLpSb3fyZ1nIen1F5jAeNRPwLTMgeB534nFUlsWaAfiO7,alias/Mynode" 12 120 --title "Add Peer" 3>&1 1>&2 2>&3)
    RC=$?
    if [[ $RC -ne 0 ]]; then
        return
    fi

    HEIGHT=$(expr $(echo "$PEER"|wc -l) + 8)
    PEER_TO_ADD=$(echo "$PEER"|tr -d ' ')
    if (whiptail --title "Add Peer" \
                 --yesno "The following peer will be added:\n\n$PEER_TO_ADD" \
                 $HEIGHT 120) then

        # Run nbctl command
        NBCTL_OUTPUT=$(nbctl -a -p "$PEER_TO_ADD" 2>&1)
        RC=$?
        if [[ $RC -eq 0 ]]; then
            HEIGHT=8
            whiptail --title "Added Peers" \
                     --msgbox "Peer added." \
                    $HEIGHT $WIDTH
        else
            if echo "$NBCTL_OUTPUT" | grep -q "urllib2.URLError" ; then
               NBCTL_OUTPUT="Failed to communicate with HORNET API port. Check if HORNET is active and if $HOME/.nbctl is configured correctly."
            fi
            HEIGHT=$(expr $(echo "$NBCTL_OUTPUT"|wc -l) + 10)
            whiptail --title "Adding Peers Failed" \
                     --msgbox "Failure: $NBCTL_OUTPUT" \
                     $HEIGHT $WIDTH
        fi
    fi
}

function remove_peers() {
    local PEERS_ARRAY_INDEXED
    local PEER_INDEX
    local PEERS_ARRAY
    local PEERS
    local PEER
    local HEIGHT

    echo "Getting peers list..."
    PEERS=$(list_peers get)
    RC=$?
    clear
    if [[ $RC -ne 0 ]]; then
        whiptail --title "Peers Failed" \
                 --msgbox "Failed to get list of peers: $PEERS" \
                 8 $WIDTH
        return
    fi
    if [ "$PEERS" == "" ]; then
        whiptail --title "No Peers" \
                 --msgbox "There are no peers configured" \
                 8 $WIDTH
        return
    fi

    PEERS=$(echo "$PEERS" | jq -r '.peers[] | "\(.alias),\(.multiAddresses[0]),\(.id)"' | column -c 80 -t)
    HEIGHT=$(expr $(echo "$PEERS"|wc -l) )
    PEERS_ARRAY=($(echo "$PEERS"))
    PEERS_ARRAY_INDEXED=($(echo "$PEERS" | awk '!/^ / && NF { print NR")"; print $1$2$3}'))
    PEER_INDEX=$(whiptail --title "Remove peers" --menu "Choose a peer" 25 120 16  "${PEERS_ARRAY_INDEXED[@]}" 3>&1 1>&2 2>&3)
    if [ $? -eq 1 ]; then
        return
    fi

    local PEER_INX=$(echo "$PEER_INDEX" | cut -d')' -f1)
    local PEER_INX=$(expr $PEER_INX - 1)
    local TO_REMOVE="${PEERS_ARRAY[$PEER_INX]}"
    local ALIAS=$(echo "$TO_REMOVE" | cut -d',' -f1)
    local ID="$(echo "$TO_REMOVE" | cut -d ',' -f3)"

    if (whiptail --title "Confirm removal" \
                 --yesno "Are you sure you want to remove:\n\n${ALIAS},${ID}" \
                 --defaultno \
                 12 $WIDTH)
    then
        REMOVAL_OUTPUT=$(nbctl -r -p "${ID}" 2>&1)
        if [ $? -eq 0 ];then
            whiptail --title "Removed successfully" \
                     --msgbox "$REMOVAL_OUTPUT" \
                     12 $WIDTH
        else
            HEIGHT=$(expr $(echo "$REMOVAL_OUTPUT"|wc -l) + 7)
            whiptail --title "Remove failed!" \
                     --msgbox "${REMOVAL_OUTPUT}" \
                     $HEIGHT $WIDTH
        fi
    fi
}

function list_peers() {
    local PEERS_QUERY
    local PEERS
    local HEIGHT
    local RETURN_RES=$1

    PEERS_QUERY=$(nbctl -s 2>&1)
    RC=$?
    if [[ $RC -ne 0 ]]; then
        if echo "$PEERS_QUERY" | egrep -q "urllib..URLError|timeout|refused" ; then
            PEERS_QUERY="Failed to communicate with HORNET API port. Check if HORNET is active and if $HOME/.nbctl is configured correctly."
        else
            PEERS_QUERY="Unknown error"
        fi
        if [ -n "$RETURN_RES" ]; then
            echo "$PEERS_QUERY"
            return 1
        fi
        HEIGHT=$(expr $(echo "$PEERS_QUERY"|wc -l) + 7)
        whiptail --title "List peers failed" \
                 --msgbox "$PEERS_QUERY" \
                 $HEIGHT $WIDTH
        return 1
    else
        #PEERS=$(echo "$PEERS_QUERY" | jq -r '.peers[] | "\(.alias) \(.multiAddresses[0]) conn: \(.connected)\n"' | column -c 80 -t)
        if [ -n "$RETURN_RES" ]; then
            echo "$PEERS_QUERY"
            return 0
        fi

        PEERS=$(echo "$PEERS_QUERY" | jq -r '.peers[] | "\(.alias) \(.multiAddresses[0])  connected: \(.connected),\n'"    "'\(.id)"' | column -c 80)
        if [ "$PEERS" == "" ]; then
            LENGTH=0
        else
            LENGTH=$(expr $(echo "$PEERS"|wc -l) / 2)
            FOR_WINDOW_LENGTH=$(($(echo "$PEERS"|wc -l)*2))
        fi
        local HEIGHT=$(expr $FOR_WINDOW_LENGTH + 8)
        whiptail --title "List Peers" \
                 --msgbox "Total: ${LENGTH} peer(s)\n\n${PEERS}" \
                 $HEIGHT $WIDTH
    fi
}

### Node info ###
function show_lmsi() {
    pause "Sorry, this is still work-in-progress. Press ENTER to return to menu."
    clear
    return

    if [ ! -f "$HOME/.nbctl" ]; then
        whiptail --title "Missing .nbctl" \
                 --msgbox "Error: cannot find $HOME/.nbctl" \
                 8 $WIDTH
        return
    fi
    HORNET_HOST=$(grep ^host "$HOME/.nbctl" | cut -d: -f2-)
    local HORNET_API_VERSION=$(grep ^api_version $HOME/.nbctl | cut -d: -f2-)
    local LSMI_LOCAL=$(curl -f -m 5 -s $HORNET_HOST -X POST -H "X-IOTA-API-Version: $HORNET_API_VERSION" -H 'Content-Type: application/json' -d '{"command": "getNodeInfo"}'| python -m json.tool|egrep "latestSolidSubtangleMilestoneIndex|latestMilestoneIndex"| sed 's/,//'|sed -e 's/^[ \t]*//'|sed 's/"//g')
    if [ $? -ne 0 ]; then
        whiptail --title "Query failed" \
                 --msgbox "Error: failed query ${LSMI_LOCAL}. Check if HORNET is active and if $HOME/.nbctl is configured properly." \
                 12 $WIDTH
        return
    fi

    local LSMI_QUERY=$(curl -H 'Cache-Control: no-cache' -s -f -m 5 https://x-vps.com/lmsi|jq -r .latestMilestoneIndex 2>/dev/null)
    if [ $? -eq 0 ]; then
        OUTPUT="Latest milestone index: ${LSMI_QUERY}\n\n"
    else
        OUTPUT=""
    fi
    OUTPUT="${OUTPUT}Local:\n\n${LSMI_LOCAL}"
    whiptail --title "LatestMilestoneIndex" \
             --msgbox "$OUTPUT" \
             12 $WIDTH
}

function get_node_info() {
    if [ ! -f $HOME/.nbctl ]; then
        whiptail --title "Missing .nbctl" \
                 --msgbox "Error: cannot find $HOME/.nbctl" \
                 8 $WIDTH
        return
    fi
    local HORNET_HOST=$(grep ^host $HOME/.nbctl | awk {'print $2'})
    local HORNET_API_VERSION=$(grep ^api_version $HOME/.nbctl | awk {'print $2'})
    NODE_RESPONSE=$(curl -f -m 5 -s ${HORNET_HOST}/api/v${HORNET_API_VERSION}/info -X GET -H "Accept: application/json" -H "Content-Type: application/json")

    # epoch time to human readable
    LMST_EPOCH=$(jq -r '.data.latestMilestoneTimestamp' <<< "$NODE_RESPONSE")
    LMST_TIME=$(echo "$LMST_EPOCH:($(date -d @${LMST_EPOCH}))" | tr ' ' '_')

    # to entries, columns, sort
    NODE_INFO=$(jq -r --arg a "$LMST_TIME" '.data.latestMilestoneTimestamp = $a | .data | to_entries[] | "\(.key): \(.value)"' <<< "$NODE_RESPONSE" | column -t | sort )
    if [ $? -ne 0 ]; then
        whiptail --title "Query failed" \
                 --msgbox "Error: failed query ${NODE_INFO}. Check if HORNET is active and if $HOME/.nbctl is configured properly." \
                 12 $WIDTH
        return
    fi

    HEIGHT=$(expr $(echo "$NODE_INFO"|wc -l) + 8)
    whiptail --title "Node Info" \
             --msgbox "$NODE_INFO" \
             $HEIGHT $WIDTH
}

### PS MEM ###
function view_ps_mem() {
    which ps_mem >/dev/null 2>&1
    if [[ $? -ne 0 ]]; then
         whiptail --title "Missing ps_mem" \
         --msgbox "Error: cannot find 'ps_mem' utility!" \
         8 $WIDTH
         return 1
    fi

    whiptail --title "ps_mem utility" \
             --msgbox "This utility shows a per-process total memory usage.\nUse arrows or page up/down to scroll and q to exit." \
             8 $WIDTH
    ps_mem 2>/dev/null|less
}

### Services ###
function service_status() {
    local SERVICE
    SERVICE=$1
    # Pipe to less as some distros don't use pager
    systemctl status $SERVICE|less
}

function service_cmd() {
    local SERVICE
    local COMMAND
    local OUTPUT
    local EXTRA_CMD
    local DISABLE
    local STATE
    SERVICE=$1
    COMMAND=$2
    EXTRA_CMD=$3

    echo "Running 'systemctl $COMMAND $SERVICE' ..."
    if [ "$EXTRA_CMD" == "disable" ]; then
        systemctl disable $SERVICE
        STATE="and disable"
    elif [ "$EXTRA_CMD" == "enable" ]; then
        systemctl enable $SERVICE
        STATE="enabled"
    fi

    if [ "$EXTRA_CMD" != "enable" ]; then
        OUTPUT=$(systemctl $COMMAND $SERVICE 2>&1)
    else
        OUTPUT=""
    fi
    HEIGHT=$(expr $(echo "$OUTPUT"|wc -l) + 7)
    if [ $? -ne 0 ]; then
        whiptail --title "Failed" \
                 --msgbox "$COMMAND $SERVICE failed: $OUTPUT" \
                 $HEIGHT 48
    else
        whiptail --title "Success" \
                 --msgbox "$COMMAND $SERVICE $STATE OK" \
                 $HEIGHT 48
    fi
    clear
}

function service_log() {
    local SERVICE
    local ARGS
    SERVICE=$1
    # Pipe to less in the case too few lines.
    # This will prevent immediately exiting the view
    journalctl -u $SERVICE|less
}

function service_menu() {
    local SERVICE
    SERVICE=$1
    whiptail --title "HORC v${__VERSION__} - $SERVICE Service" \
             --menu "For logs use SHIFT-g to skip to end of log, or q to exit." \
             --cancel-button "Back" \
             25 $WIDTH 16 \
    "a)" "Status" \
    "b)" "Start" \
    "c)" "Stop" \
    "d)" "Restart" \
    "e)" "Disable start on reboot" \
    "f)" "Enable start on reboot" \
    "g)" "View log" \
    3>&1 1>&2 2>&3
}

function service() {
    local SERVICE
    local CHOICE
    SERVICE=$1
    CHOICE=$(service_menu $SERVICE)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi
    case "$CHOICE" in

        "a)")
            service_status $SERVICE
            service $SERVICE
            ;;

        "b)")
            service_cmd $SERVICE start
            service $SERVICE
            ;;

        "c)")
            service_cmd $SERVICE stop
            service $SERVICE
            ;;

        "d)")
            service_cmd $SERVICE restart
            service $SERVICE
            ;;

        "e)")
            service_cmd $SERVICE stop disable
            service $SERVICE
            ;;

        "f)")
            service_cmd $SERVICE "" enable
            service $SERVICE
            ;;

        "g)")
            service_log $SERVICE
            service $SERVICE
            ;;

        *)
            service $SERVICE
            ;;
    esac
}

function services_menu() {
    whiptail --title "HORC v${__VERSION__} - Node Services" \
             --menu "Choose an option" \
             --cancel-button "Back" \
             15 $WIDTH 8 \
    "a)" "Hornet" \
    "b)" "Nginx" \
    3>&1 1>&2 2>&3
}

function services() {
    local CHOICE
    CHOICE=$(services_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi
    case "$CHOICE" in

        "a)")
            service hornet
            services
            ;;

        "b)")
            service nginx
            services
            ;;

        *)
           services
           ;;
    esac
}

### Rerun playbook installation ###
function rerun_playbook() {

    if (whiptail --title "Rerun Playbook Method" \
                 --yesno "Sometimes you may want to rerun the entire installation if you think something has changed and you want to try to reset the node to its initial state.\nThere are two options:\n\n1. simply rerun the installation\n2. use the override method: it will reset any configurations you may have configured manually.\n\nIf you would like to use the override method choose Yes else choose No for normal rerun.\n\nNote that existing configuration files will be backed up so you can restore e.g. peers and other settings later on.\n" \
                 --defaultno \
             20 $WIDTH) then
        local OVERWRITE=yes
    else
        local OVERWRITE=no
    fi

    if ! (whiptail --title "Rerun Playbook Confirm" \
                   --yesno "This option will allow you to rerun the entire installation.\nUsing override method: $OVERWRITE\n\nWould you like to proceed?\n" \
                   --defaultno \
          12 $WIDTH) then
        return
    fi

    verify_playbook
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Cannot rerun Hornet installation, unknown error." \
                 8 $WIDTH
        return 1
    fi
    cd /opt/hornet-playbook && ansible-playbook -i inventory site.yml -v -e "overwrite=$OVERWRITE"
    [[ $? -ne 0 ]] && MSG="Rerunning the playbook installation failed!!! Check output above for errors." || MSG="Rerun finished successfully!"
    pause "$MSG Press ENTER to return to menu."
    clear
}

### Clean Dangling Images ###
function remove_dangling_images() {
    local DANGLING_IMAGES
    DANGLING_IMAGES=($(/usr/bin/docker images -f "dangling=true" -q))
    if [[ ${#DANGLING_IMAGES[@]} -gt 0 ]]; then
        /usr/bin/docker rmi -f $(/usr/bin/docker images -f "dangling=true" -q)
        return $?
    fi
}

### Cleanup Docker Images ###
function cleanup_docker_images() {
    if (whiptail --title "Cleanup Docker Images" \
                 --yesno "To free up some diskspace you can delete unused docker images and volumes. For services that are temporarily off this isn't a problem: the image will be pulled again once you start up the service.\n\nWould you like proceed?" \
                 --defaultno \
                 14 $WIDTH) then
        echo "Removing unused volumes, please wait..."
        /usr/bin/docker volume prune -f

        echo "Removing unused images, please wait..."
        /usr/bin/docker image prune -a -f

        echo "Removing dangling images, please wait..."
        remove_dangling_images
        [[ $? -ne 0 ]] && MSG="Failed to cleanup unused images! Check output above for errors. " || MSG="Cleanup finished successfully! "
        pause "${MSG}Press ENTER to return to menu."
        clear
    fi
}

### Update config.json ###
function update_config() {
    if ! (whiptail --title "Update config.json" \
                   --yesno "This option will allow you to update config.json according to the playbook's variables.\nThis will update the configuration if there was any update to it or if you want to reset any modifications you have done to it manually.\n\nWould you like to proceed?\n" \
                   --defaultno \
          12 $WIDTH) then
        return
    fi

    verify_playbook
    if [[ $? -ne 0 ]]; then
        whiptail --title "Error!" \
                 --msgbox "ERROR: Cannot update config.json, unknown error trying to git pull." \
                 8 $WIDTH
        return 1
    fi
    cd /opt/hornet-playbook \
      && git pull \
      && ansible-playbook -v -i inventory \
                          site.yml \
                          --tags=hornet_config_file \
                          -e overwrite=yes
    [[ $? -ne 0 ]] && MSG="Failed to update config.json! Check output above for any errors. " || MSG="Update finished successfully! "
    pause "${MSG}Press ENTER to return to menu."
}

### Notice ###
function how_to_setup() {
    whiptail --title "HORC v${VERSION} - Instructions" \
             --msgbox "Check that you have the .nbctl file in your home folder (ls -l ~/.nbctl).\nExample of the file's contents:\n\napi_version: 1\nhost: http://127.0.0.1:14265\nfile: /var/lib/hornet/peering.json\n\nThis will allow this script to use the nbctl utility to manage peers and get the node's data." \
             15 $WIDTH
}

### Configure files ###
function configure_files_menu() {
    whiptail --title "HORC v${__VERSION__} - Configure Files" \
             --menu "Choose an option" \
             --cancel-button "Back" \
              22 48 12 \
    "a)" "Hornet System Config" \
    "b)" "Hornet Main Config" \
    "c)" "Hornet Peers Config" \
    "Z)" "Choose Editor" \
    3>&1 1>&2 2>&3
}

function configure_files() {
    local CHOICE
    local CONFIG_FILE
    CONFIG_FILE=$(grep ^base_config "$HOME/.nbctl" | awk {'print $2'})
    CHOICE=$(configure_files_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi

    case "$CHOICE" in
        "a)")
            edit_config "$SYSCONFIG_FILE" "hornet"
            configure_files
            ;;

        "b)")
            edit_config "${CONFIG_FILE}" "hornet"
            configure_files
            ;;

        "c)")
            edit_config "/var/lib/hornet/peering.json" "hornet"
            configure_files
            ;;

        "Z)")
            choose_editor
            configure_files
            ;;

        *)
            configure_files
            ;;
    esac

}

### Hornet Plugins ###
function hornet_plugins() {
    local RESULTS=
    local ORIGINAL_NODE_OBJ=
    local NEW_NODE_OBJ=
    local JSON_OUTPUT=
    local CONFIG_FILE=
    local PLUGINS_FILE=

    # By default list all the existing plugins as disabled
    export ENABLE_PLUGINS=""
    export DISABLE_PLUGINS="Spammer,ZMQ,MQTT,Prometheus,Coordinator,Autopeering"
    declare -A PLUGINS_STATE

    CONFIG_FILE=$(grep ^base_config "$HOME/.nbctl" | awk {'print $2'})
    PLUGINS_FILE="/opt/hornet-playbook/group_vars/all/z-plugins.yml"

    # Save current config state
    ORIGINAL_NODE_OBJ=$(jq -r '.node | "\(.enablePlugins) \(.disablePlugins)"' < "$CONFIG_FILE")

    IFS=', ' read -r -a DISABLE_PLUGINS_ARRAY <<< "$DISABLE_PLUGINS"
    for PLUGIN in "${DISABLE_PLUGINS_ARRAY[@]}"
    do
        if jq -e -r '.node.enablePlugins | index("'${PLUGIN}'")' < "$CONFIG_FILE" >/dev/null
        then
            PLUGINS_STATE[${PLUGIN}]="ON"
        else
            PLUGINS_STATE[${PLUGIN}]="OFF"
        fi
    done

    RESULTS=$(whiptail --title "HORC v${__VERSION__} - Plugins" \
        --checklist \
        --cancel-button "Exit" \
        "\nPlease choose plugins to enable or disable.\n\
Select/unselect options using space and\nclick Enter to proceed.\n" 17 60 "${#DISABLE_PLUGINS_ARRAY[@]}" \
        Spammer           "...         Spammer" "${PLUGINS_STATE[Spammer]}" \
        ZMQ               "...         ZeroMQ" "${PLUGINS_STATE[ZMQ]}" \
        MQTT              "...         MQTT" "${PLUGINS_STATE[MQTT]}" \
        Prometheus        "...         Prometheus Metrics" "${PLUGINS_STATE[Prometheus]}" \
        Coordinator       "...  (*dev) Comnet Coordinator" "${PLUGINS_STATE[Coordinator]}" \
        Autopeering       "...         Autopeering" "${PLUGINS_STATE[Autopeering]}" \
        3>&1 1>&2 2>&3)

    RC=$?
    [[ $RC -ne 0 ]] && return

    read -a RESULTS_ARRAY <<< "$RESULTS"
    for CHOICE in "${RESULTS_ARRAY[@]}"
    do
        ENABLE_PLUGINS+=",${CHOICE//\"}"
        DISABLE_PLUGINS_ARRAY=("${DISABLE_PLUGINS_ARRAY[@]/${CHOICE//\"}/}")
    done

    DISABLE_PLUGINS=$(printf "%s,"  "${DISABLE_PLUGINS_ARRAY[@]}")
    JSON_OUTPUT=$(cat "$CONFIG_FILE" | python -c '
import json, sys, os
obj = json.load(sys.stdin)
enable_plugins = os.environ["ENABLE_PLUGINS"]
disable_plugins = os.environ["DISABLE_PLUGINS"]
obj["node"]["enablePlugins"] = [p for p in enable_plugins.split(",") if p != ""]
obj["node"]["disablePlugins"] = [p for p in disable_plugins.split(",") if p != ""]
print(json.dumps(obj))
')

    NEW_NODE_OBJ=$(jq -r '.node | "\(.enablePlugins) \(.disablePlugins)"' <<<"$JSON_OUTPUT")
    [[ "$ORIGINAL_NODE_OBJ" == "$NEW_NODE_OBJ" ]] && return

    # Make consistent in yaml variables file
    YAML_OUTPUT=$(python -c '
import yaml, os
obj = {"hornet_disable_plugins":{}, "hornet_enable_plugins":{}}
enable_plugins = os.environ["ENABLE_PLUGINS"]
disable_plugins = os.environ["DISABLE_PLUGINS"]
obj["hornet_enable_plugins"] = [p for p in enable_plugins.split(",") if p != ""]
obj["hornet_disable_plugins"] = [p for p in disable_plugins.split(",") if p != ""]
print(yaml.dump(obj))
')
    echo "$YAML_OUTPUT" >"$PLUGINS_FILE"

    # Produce new config
    jq . <<< "$JSON_OUTPUT" > "$CONFIG_FILE"

    if (whiptail --title "Restart Hornet" \
             --yesno "You've made changes to the plugins. A restart of HORNET is needed to load the new configuration.\n\nRestart now?" \
             --defaultno \
             10 $WIDTH) then
        echo "Restarting hornet, please wait ..."
        /bin/systemctl restart hornet
    fi

}

### Toggle Comnet ###
function toggle_comnet(){
    pause "Sorry, this is still work-in-progress. Press ENTER to return to menu."
    clear
    return

    local TO="comnet"
    local FROM="mainnet"
    local MSG

    if [ -f "/opt/hornet-playbook/group_vars/all/z-comnet-vars.yml" ]
    then
        TO="mainnet"
        FROM="comnet"
    fi

    MSG="This node seems to be configured for $FROM at the moment.\n\nWould you like to switch it to $TO?"
    if ! (whiptail --title "Toggle ComNet" \
                 --yesno "${MSG}" \
                 --defaultno \
                 10 $WIDTH) then
        return
    fi

    if [ "$TO" == "comnet" ]
    then
        cp -- "/opt/hornet-playbook/roles/shared-files/comnet-vars.yml" "/opt/hornet-playbook/group_vars/all/z-comnet-vars.yml"
    else
        rm "/opt/hornet-playbook/group_vars/all/z-comnet-vars.yml"
    fi

    echo "Stopping HORNET ..."
    /bin/systemctl stop hornet

    # Cleanup
    rm -f /var/lib/hornet/snapshot/export.bin /var/lib/hornet/mainnetdb/*

    # Reconfigure
    cd /opt/hornet-playbook \
      && ansible-playbook -v site.yml \
                          -i inventory \
                          -e overwrite=yes \
                          --tags="hornet_config_files"

    MSG="Node configured for ${TO}."
    pause "$MSG Press ENTER to return to menu."
}

function set_node_peer_id(){
    local OUTPUT
    local TAG
    local PRIVATE_KEY
    local PEER_ID

    if grep -q ^hornet_config_p2p_identityPrivateKey /opt/hornet-playbook/group_vars/all/z-installer-override.yml
    then
        if ! (whiptail --title "Existing private key" \
                 --yesno "Node already has a private key set in /opt/hornet-playbook/group_vars/all/z-installer-override.yml\n\nWould you like to re-generate the ID? (Note that you'll have to let your existing peers know about the ID change)." \
                 --defaultno \
                 12 $WIDTH)
        then
            return 0
        fi
    fi

    if [ -f "/etc/default/hornet" ]
    then
        TAG=$(grep ^TAG /etc/default/hornet | cut -d'=' -f 2)
    elif [ -f "/etc/sysconfig/hornet" ]
    then
        TAG=$(grep ^TAG /etc/sysconfig/hornet | cut -d'=' -f 2)
    fi

    echo "Get new ID ..."
    OUTPUT=$(/usr/bin/docker run -it --rm --name getp2pID "gohornet/hornet:${TAG}" tools p2pidentity)

    # TODO: open github issue for hornet team to output in json format as an option
    PRIVATE_KEY=$(echo "$OUTPUT" | sed 's|^.*Your p2p private key: \([a-f0-9]*\)|\1|' | head -1 | tr -d ' ' | tr -d '\r')
    PEER_ID=$(echo "$OUTPUT" | tail -1 | awk -F":" {'print $2'} | tr -d ' ' | tr -d '\r')

    # Make sure old values are gone
    sed -i '/^hornet_config_p2p_identityPrivateKey/d' /opt/hornet-playbook/group_vars/all/z-installer-override.yml
    sed -i '/^hornet_config_p2p_identityPeerID/d' /opt/hornet-playbook/group_vars/all/z-installer-override.yml

    echo "hornet_config_p2p_identityPrivateKey: $PRIVATE_KEY" >> /opt/hornet-playbook/group_vars/all/z-installer-override.yml
    echo "hornet_config_p2p_identityPeerID: $PEER_ID" >> /opt/hornet-playbook/group_vars/all/z-installer-override.yml

    tmpfile=$(mktemp /tmp/hornet.config.XXXXXX)
    cp -- "/var/lib/hornet/config.json" "/var/lib/hornet/config.json.$(date +%s)"
    jq '.p2p.identityPrivateKey="'$PRIVATE_KEY'"' < /var/lib/hornet/config.json > "$tmpfile"
    mv -- "$tmpfile" "/var/lib/hornet/config.json"
    chown hornet:hornet "/var/lib/hornet/config.json"
    chmod 600 "/var/lib/hornet/config.json"

    echo "Stopping hornet to remove old identity ..."
    /bin/systemctl stop hornet

    rm -rf /var/lib/hornet/p2p/*

    echo "Starting hornet with new identity ..."
    /bin/systemctl start hornet

    pause "Done setting new peer ID. Press ENTER to return to menu."
}

### Peers ###
function peers_menu(){
    whiptail --title "HORC v${__VERSION__} - Peers" \
             --menu "Choose an option" \
             --cancel-button "Back" \
              12 48 4 \
    "a)" "Add Peers" \
    "b)" "Remove peers" \
    "c)" "List peers" \
    3>&1 1>&2 2>&3
}

function peers(){
    local CHOICE
    CHOICE=$(peers_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        return
    fi

    case "$CHOICE" in
        "a)")
            add_peer
            peers
            ;;

        "b)")
            remove_peers
            peers
            ;;

        "c)")
            list_peers
            peers
            ;;

        *)
            peers
            ;;
    esac
}

### Main Menu ###
function main_menu() {
    local MENU="Choose an option"
    if check_new_horc; then
        MENU="${MENU}\n(*HORC update available)"
    fi

    if check_new_hornet; then
        MENU="${MENU}\n(*HORNET update available)"
    fi

    whiptail --title "HORC v${__VERSION__} - Hornet Configuration Menu" \
             --menu "$MENU" \
             --cancel-button "Exit" \
             29 $WIDTH 18 \
    "a)" "Update Hornet Software" \
    "b)" "Hornet Plugins" \
    "c)" "Manage Services" \
    "d)" "Configure Files" \
    "e)" "View Per Processes Memory Usage" \
    "f)" "Rerun Playbook Installation" \
    "g)" "Clean Unused Docker Images" \
    "h)" "Update HORC and node scripts" \
    "i)" "Enable HTTPS / Certificate" \
    "j)" "Get Node Info" \
    "k)" "Show LatestMilestoneIndex" \
    "l)" "Get new snapshot DB" \
    "m)" "Set DB Maximum Size" \
    "n)" "Peers" \
    "o)" "Update config.json" \
    "p)" "Set node Peer ID" \
    "Z)" "Configure this Script" \
    3>&1 1>&2 2>&3
}

function run_main_menu() {
    local CHOICE
    CHOICE=$(main_menu)
    RC=$?
    if [[ $RC -eq 1 ]]; then
        exit
    fi

    case "$CHOICE" in
        "Z)")
            how_to_setup
            run_main_menu
            ;;

        "a)")
            upgrade_hornet
            run_main_menu
            ;;

        "b)")
            hornet_plugins
            run_main_menu
            ;;

        "c)")
            services
            run_main_menu
            ;;

        "d)")
            configure_files
            run_main_menu
            ;;

        "e)")
            view_ps_mem
            run_main_menu
            ;;

        "f)")
            rerun_playbook
            run_main_menu
            ;;

        "g)")
            cleanup_docker_images
            run_main_menu
            ;;

        "h)")
            update_horc
            run_main_menu
            ;;

        "i)")
            enable_https
            run_main_menu
            ;;

        "j)")
            get_node_info
            run_main_menu
            ;;

        "k)")
            show_lmsi
            run_main_menu
            ;;

        "l)")
            get_db
            run_main_menu
            ;;

        "m)")
            set_db_max_size
            run_main_menu
            ;;

        "n)")
            peers
            run_main_menu
            ;;

        "o)")
            update_config
            run_main_menu
            ;;

        "p)")
            set_node_peer_id
            run_main_menu
            ;;

        *)
            run_main_menu
            ;;
    esac
}

# Get OS and version
set_dist

# Run custom updates
run_custom_updates

# Run main menu
run_main_menu
